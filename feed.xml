<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/" rel="alternate" type="text/html" /><updated>2021-07-25T08:05:34+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/feed.xml</id><title type="html">wjohn1483.github.io</title><subtitle></subtitle><author><name>Your Name</name></author><entry><title type="html">Object Detection概論</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/07/25/object-detection/" rel="alternate" type="text/html" title="Object Detection概論" /><published>2021-07-25T00:00:00+00:00</published><updated>2021-07-25T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/07/25/object-detection</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/07/25/object-detection/">&lt;p&gt;簡單整理一下目前有關object detection的一些研究。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;暴力做object-detection&quot;&gt;暴力做Object Detection&lt;/h2&gt;

&lt;p&gt;隨著深度學習的興起，現在已經有各式各樣的model可以幫助我們做image classification，辨識出圖片裡面的是什麼東西。如果想要直接用這些model做物件偵測，一個簡單暴力的方式是，用不同大小的方框掃過整張圖片，把每一個方框的圖片都丟進去model裡面做物件分類來達到物件偵測的效果。&lt;/p&gt;

&lt;h2 id=&quot;region-with-cnnr-cnn&quot;&gt;Region with CNN（R-CNN）&lt;/h2&gt;

&lt;p&gt;在前面提到我們可以用不同的方框掃過整張圖片來做物件偵測，但這樣的效率明顯不高，而且很吃計算量，這邊要介紹的&lt;a href=&quot;https://arxiv.org/pdf/1311.2524.pdf&quot;&gt;R-CNN&lt;/a&gt;便是透過Selective Search來選取可能有東西的區域，再拿去model裡面分類，其大致上的流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;產生大約2000個可能有東西的區域（Region Proposals）&lt;/li&gt;
  &lt;li&gt;透過預先訓練好的模型像是AlexNet、Inception等抽取圖片特徵&lt;/li&gt;
  &lt;li&gt;將特徵透過SVM來去分辨裡面有沒有含有特定物體&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;./rcnn_architecture.png&quot; alt=&quot;R-CNN Architecture&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;selective-search&quot;&gt;Selective Search&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://ivi.fnwi.uva.nl/isis/publications/2013/UijlingsIJCV2013/UijlingsIJCV2013.pdf&quot;&gt;Selective search&lt;/a&gt;是以&lt;a href=&quot;http://cs.brown.edu/people/pfelzens/papers/seg-ijcv.pdf&quot;&gt;Graph Based Segmentation&lt;/a&gt;的結果為基礎，使用階層群聚演算法來得到要輸入進model的region proposal，Graph Based Segmentation在Open CV裡面有支援，使用的方式可以參考&lt;a href=&quot;https://blog.gtwang.org/programming/opencv-graph-based-segmentation-tutorial/&quot;&gt;這篇部落格&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;階層群聚演算法會從Graph Based Segmentation的結果裡面，每次挑選出兩個最相近的區塊做合併，而相似度的計算包含了顏色、紋理、大小等等的因素，綜合起來來判斷兩個區塊的相似度，詳細的介紹可以參考&lt;a href=&quot;https://blog.gtwang.org/programming/selective-search-for-object-detection/&quot;&gt;這篇部落格&lt;/a&gt;，具體演算法的流程可以參考下圖。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./selective_search_algorithm.png&quot; alt=&quot;Selective Search Algorithm&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;bounding-box-regression&quot;&gt;Bounding-box Regression&lt;/h3&gt;

&lt;p&gt;R-CNN除了使用selective search找到有可能的region proposal以外，有另外透過bounding-box regression來調整selective search框出來的bounding box。&lt;/p&gt;

&lt;p&gt;對於每一個bounding box，我們可以透過\((x, y, w, h)\)​來表示，這四個數值分別代表這個bounding box中心點座標和長寬，而bounding-box regression是想要透過一個平移加縮放的mapping function \(f()\)​來把selective search得到的bounding box \((P_x, P_y, P_w, P_y)\)透過轉換以後可以越接近label好的bounding box \((G_x, G_y, G_w, G_h)\)​越好。&lt;/p&gt;

\[f(P_x, P_y, P_w, P_y)=(\hat{G}_x, \hat{G}_y, \hat{G}_w, \hat{G}_h)\approx(G_x, G_y, G_w, G_h)\]

&lt;p&gt;透過將\(f()\)​弄成regression task，之後便可以透過gradient descent來訓練\(f()\)​，更詳細的說明可以參考&lt;a href=&quot;https://blog.csdn.net/zijin0802034/article/details/77685438&quot;&gt;這篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;fast-r-cnn&quot;&gt;Fast R-CNN&lt;/h2&gt;

&lt;p&gt;在上面的R-CNN裡面，每一個region proposal都會被丟進預先訓練好的模型來抽取圖片特徵，然而很多時候region proposal之間會有重疊的部分，其實並不需要重新再算一遍，因此在&lt;a href=&quot;https://arxiv.org/pdf/1504.08083.pdf&quot;&gt;Fast R-CNN&lt;/a&gt;裡面想要直接把region proposal對應到feature map中，來避免掉不必要的計算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./fast_rcnn_architecture.png&quot; alt=&quot;Fast R-CNN Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fast R-CNN跟R-CNN一樣，會先需要先選好region proposal，在把圖片經過CNN得到feature map的時候，也會將選好的region proposal也投影到跟feature map一樣的大小，直接對該區塊內的feature map做max pooling後得到固定大小的feature，最後透過fully connected layers來得到region裡面物體的類別，以及對bounding box做回歸，這個方法被稱作Region of Interest Pooling（RoI Pooling）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://deepsense.ai/wp-content/uploads/2017/02/roi_pooling-1.gif&quot; alt=&quot;RoI Pooling&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://deepsense.ai/region-of-interest-pooling-explained/&quot;&gt;Region of interest pooling explained&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;faster-r-cnn&quot;&gt;Faster R-CNN&lt;/h2&gt;

&lt;p&gt;在Fast R-CNN裡面還是會需要跑selective search來得到region proposal，而&lt;a href=&quot;https://arxiv.org/pdf/1506.01497.pdf&quot;&gt;Faster R-CNN&lt;/a&gt;的想法是想要直接在CNN的feature map裡面透過Region Proposal Network來直接得到region proposal。&lt;/p&gt;

&lt;p&gt;Region Proposal Network是一個CNN，它會先用個sliding window去掃過整張圖片，在每個window的中心點去套用\(k\)​​個預先定義好、不同大小的anchor box，將anchor box框出來的feature map輸入進CNN以後，predict出含有物體的機率，以及實際bounding box的座標。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./region_proposal_network.png&quot; alt=&quot;Region Proposal Network&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其整體的架構畫出來大概長底下這樣，中間的區塊是Faster R-CNN提出來的RPN，而右邊的是原本Fast R-CNN既有的部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./faster_rcnn_graph.png&quot; alt=&quot;Faster R-CNN Graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://blog.csdn.net/jiongnima/article/details/79094159&quot;&gt;实例分割模型Mask R-CNN详解：从R-CNN，Fast R-CNN，Faster R-CNN再到Mask R-CNN&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;mask-r-cnn&quot;&gt;Mask R-CNN&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.06870.pdf&quot;&gt;Mask R-CNN&lt;/a&gt;在Faster R-CNN的基礎上，修改了RoI Pooling，調整成RoI Align，並多加入Mask prediction。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./mask_rcnn_graph.png&quot; alt=&quot;Mask R-CNN Graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://blog.csdn.net/jiongnima/article/details/79094159&quot;&gt;实例分割模型Mask R-CNN详解：从R-CNN，Fast R-CNN，Faster R-CNN再到Mask R-CNN&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;roi-align&quot;&gt;RoI Align&lt;/h3&gt;

&lt;p&gt;在原本RoI Pooling的使用情境下，會需要在把region proposal投影到feature map的維度時把座標取整數，在計算max pooling的時候也需要對區塊的範圍取整數，雖然說在feature map上面取整數去除掉的零頭看起來不大，但feature map實際上是圖片經過了很多CNN，濃縮過的feature，去除掉的零頭在原本圖片上的影響其實是比想像中大的。&lt;/p&gt;

&lt;p&gt;因此在Mask R-CNN裡面使用bilinear interpolation來避免掉取整數的問題，下圖中的藍色方框是CNN輸出的feature map，而黑色方框是RoI，藉由interpolation的方式來計算出要輸入至後面的feature。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;roi_align.png&quot; alt=&quot;RoI Align&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mask-prediction&quot;&gt;Mask Prediction&lt;/h3&gt;

&lt;p&gt;在Mask R-CNN做的另一件事情是引入&lt;a href=&quot;https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Long_Fully_Convolutional_Networks_2015_CVPR_paper.pdf&quot;&gt;Fully Convolutional Networks（FCN）&lt;/a&gt;來做pixel-wise的mask，FCN主要是先使用CNN來對圖片做降維，之後再透過deconvolution CNN來把feature還原到圖片原本的大小，並predict出segmentation。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./fcn_diagram.png&quot; alt=&quot;FCN Diagram&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;yolo&quot;&gt;YOLO&lt;/h2&gt;

&lt;p&gt;前面所提的R-CNN們都是region-based的方法，會需要先決定有可能的region proposal再往後進行下去，而&lt;a href=&quot;https://pjreddie.com/media/files/papers/yolo.pdf&quot;&gt;YOLO&lt;/a&gt;是You Only Look Once的縮寫，一個region-free的方法，希望可以只跑一次CNN就同時產生出bounding box和物體的類別。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;yolo_model.png&quot; alt=&quot;YOLO Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先，YOLO會先把圖片切成\(S \times S\)​個grid，並讓每一個grid都用neural network去預測\(B\)​個可能的bounding box、含有物件的信心程度以及物件的類別。在圖中上半部不同的黑框便是預測出來的bounding box，而不同的粗細表示信心程度的大小，而下半部是物件類別的預測結果。&lt;/p&gt;

&lt;p&gt;在選出了有可能的bounding box和類別偵測的結果以後，會先用一個固定的threshold把信心程度太低的bounding box去除掉，然後使用Non-Maximum Supression（NMS）來計算出最後的輸出結果，NMS運作的方式可以參考&lt;a href=&quot;https://chih-sheng-huang821.medium.com/%E6%A9%9F%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92-%E7%89%A9%E4%BB%B6%E5%81%B5%E6%B8%AC-non-maximum-suppression-nms-aa70c45adffa&quot;&gt;這篇文章&lt;/a&gt;，裡頭有詳細的圖解可以參考。&lt;/p&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/programming/opencv-graph-based-segmentation-tutorial/&quot;&gt;OpenCV 教學：實作 Graph Based Segmentation 圖形分割演算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/programming/selective-search-for-object-detection/&quot;&gt;OpenCV 教學：實作 Selective Search 物體偵測候選區域演算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/zijin0802034/article/details/77685438&quot;&gt;边框回归(Bounding Box Regression)详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ccshenyltw.medium.com/object-detection-r-cnn-fast-rcnn-faster-rcnn-mask-rcnn-retinanet-to-be-continued-71b67640445&quot;&gt;Object Detection : R-CNN, Fast-RCNN, Faster RCNN&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/cubo-ai/%E7%89%A9%E9%AB%94%E5%81%B5%E6%B8%AC-object-detection-740096ec4540&quot;&gt;關於影像辨識，所有你應該知道的深度學習模型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/jiongnima/article/details/79094159&quot;&gt;实例分割模型Mask R-CNN详解：从R-CNN，Fast R-CNN，Faster R-CNN再到Mask R-CNN&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://deepsense.ai/region-of-interest-pooling-explained/&quot;&gt;Region of interest pooling explained&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chih-sheng-huang821.medium.com/%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92-%E7%89%A9%E4%BB%B6%E5%81%B5%E6%B8%AC-you-only-look-once-yolo-4fb9cf49453c&quot;&gt;深度學習-物件偵測:You Only Look Once (YOLO)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chih-sheng-huang821.medium.com/%E6%A9%9F%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92-%E7%89%A9%E4%BB%B6%E5%81%B5%E6%B8%AC-non-maximum-suppression-nms-aa70c45adffa&quot;&gt;機器/深度學習: 物件偵測 Non-Maximum Suppression (NMS)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Computer-Vision" /><category term="Object-Detection" /><summary type="html">簡單整理一下目前有關object detection的一些研究。</summary></entry><entry><title type="html">深度學習於語音辨識</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/07/18/speech-recognition-with-deep-learning/" rel="alternate" type="text/html" title="深度學習於語音辨識" /><published>2021-07-18T00:00:00+00:00</published><updated>2021-07-18T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/07/18/speech-recognition-with-deep-learning</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/07/18/speech-recognition-with-deep-learning/">&lt;p&gt;在&lt;a href=&quot;https://wjohn1483.github.io/2021/06/14/introduction-to-speech-recognition/&quot;&gt;先前的文章&lt;/a&gt;裡頭，介紹了在深度學習蓬勃發展之前，語音辨識大概是如何達成的，而這篇文章會簡單介紹一下，在加入了深度學習以後，語音辨識的技術有了什麼樣的更動。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;過去在做語音辨識的時候，會需要不同的模型互相協作，而隨著深度學習的發展，有些語音辨識的方法已經可以將所有的模型整合成一個模型，大大簡化了語音辨識的複雜度。&lt;/p&gt;

&lt;h2 id=&quot;listen-attend-and-spelllas&quot;&gt;Listen, Attend and Spell（LAS）&lt;/h2&gt;

&lt;p&gt;第一個要提到的模型是LAS，是一個End-to-end的語音辨識模型，輸入語音訊號，輸出就是character。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./LAS_model_architecture.png&quot; alt=&quot;LAS Model Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上圖為LAS模型的架構，其實就是一個sequence to sequence的model搭配attention，不過比較特別的是，在encoder也就是上圖中的Listener裡頭，使用的是pyramidal bidirectional LSTM，因為輸入的語音訊號的個數通常都遠大於輸出的字數，所以透過pyramidal的方式來減少decoder attend的數量；另一個特別的地方是，在decoder的也就是上圖中的Speller裡面，仍然會將RNN的輸出拉回來放進下一個時間點的輸入。&lt;/p&gt;

&lt;p&gt;LAS的model雖然可以幫助我們做語音辨識，但這個模型需要將整個句子都聽完才可以開始辨識，如果輸入進來的語音訊號很長，或是想要對串流語音做語音辨識，就得要使用其他的方式，可以參考底下的方法。&lt;/p&gt;

&lt;h2 id=&quot;connectionist-temporal-classificationctc&quot;&gt;Connectionist Temporal Classification（CTC）&lt;/h2&gt;

&lt;p&gt;CTC是一種基於RNN loss function的方法，可以把比較長的輸入\(X\)轉換成比較短的輸出\(Z\)，跟語音辨識所需要的條件相同，而CTC的特點在於輸出的時候會多一個&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blank&lt;/code&gt;的符號，每一個時間點RNN的輸出除了可以是vocabulary裡面的字以外，還可以是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blank&lt;/code&gt;，寫作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./CTC_model_architecture.png&quot; alt=&quot;CTC Model Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假如說我們拿一段語音訊號\(X=[x_1, x_2, ..., x_T]\)輸入到LSTM裡面，每個時間點LSTM都會輸出一個長度為\(L+1\)的向量\(y_t=[y_t^{-}, y_t^1, ..., y_t^L]\)，其中\(L\)表示vocabulary的大小，雖然我們知道這整段語音訊號\(X\)所對應到的文字是\(Z=[z_1, z_2, ..., z_U]\)，但因為LSTM整個輸出的長度跟輸入長度相同，都是\(T\)，而文字的長度是\(U\)，兩者對不起來，沒辦法直接一對一對應做gradient descent，所以CTC在這裡使用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blank&lt;/code&gt;並將\(Z\)裡面的文字重複來把\(Z\)的長度擴充到跟\(T\)一樣，並搭配一個mapping function \(B()\)來把所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blank&lt;/code&gt;和相鄰的重複輸出去除掉，保留不相鄰的輸出。&lt;/p&gt;

&lt;p&gt;舉例來說，假設今天放進LSTM的\(X\)長度為4，而對應的\(Z\)為\([讚, 啦]\)，我們可以透過加入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;或重複\(Z\)裡面的字來讓長度變為4，之後再讓\(B()\)幫我們把修改過的輸出\(Z^*\)的輸出對回\(Z\)，亦即&lt;/p&gt;

\[B([-, 讚, 啦, 啦])=[讚, 啦] \\
B([讚, 讚, 啦, 啦])=[讚, 啦] \\
B([-, 讚, 啦, -])=[讚, 啦]\]

&lt;p&gt;其中每一個\(B()\)的輸入\([-, 讚, 啦, 啦]\)、\([讚, 讚, 啦, 啦]\)等都可以是LSTM用來學習的目標，而我們會透過&lt;a href=&quot;https://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm&quot;&gt;Forward-backward Algorithm&lt;/a&gt;來將所有可能的組合都囊括進來。&lt;/p&gt;

&lt;p&gt;我們將LSTM每一個時間點的輸出\(y_t\)攤開來，並取出所有在\(Z\)裡面文字的機率，再在每個label之間都插入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blank&lt;/code&gt;的符號，如上圖中的上半部。在這邊，我們限定每個時間點的轉移只能往右邊或右上角走，不能往右下或左邊走，如此便可以透過Forward Algorithm將最後一個時間點的機率總和來當作觀察到輸出\(Z\)的機率\(P(Z\vert X)\)，其中每一個可能的\(Z^*\)的機率可以被表示為&lt;/p&gt;

\[P(Z^*\vert X)=\coprod\limits_{t=1}\limits^{T}y_t^{Z^*_t}\]

&lt;p&gt;而\(P(Z\vert X)\)可以被表示為&lt;/p&gt;

\[P(Z\vert X)=\sum\limits_{Z^* \in B^{-1}(Z)}P(Z^*\vert X)\]

&lt;p&gt;最後就可以透過底下的loss function做訓練了&lt;/p&gt;

\[\mathcal{L}_{CTC}=-\sum\limits_{\forall(X,Z^*)\in\theta}\ln P(Z^*\vert X)\]

&lt;p&gt;訓練完CTC以後，就可以直接將聲音訊號餵進去，選擇每一個時間點最大的文字搭配\(B()\)當作是語音辨識的輸出，也可以使用beam search來增進performance。&lt;/p&gt;

&lt;h2 id=&quot;rnn-transducerrnn-t&quot;&gt;RNN Transducer（RNN-T）&lt;/h2&gt;

&lt;p&gt;在上述CTC的部分裡面，我們透過在label裡面加入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blank&lt;/code&gt;來讓串流語音辨識成為可能，然而在CTC裡面，每一個時間點的輸出跟下一個時間點的輸出是互相獨立的，這會使得後面時間的要輸出的時候因為不確定前面輸出過了沒造成結巴的現象，而RNN-T所做的改動便是將上一個時間點的輸出拉回來當作是下一個時間點的輸入，並改變predict文字的方式。&lt;/p&gt;

&lt;p&gt;在前面CTC的部分裡，每一個時間點LSTM會吃一個向量進來，輸出一個文字，但在RNN-T裡面，每一個時間點LSTM會重複吃一同個向量，直到predict出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;以後才會吃下一個輸入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph BT;
    LSTM1[LSTM]
    LSTM2[LSTM]
    LSTM3[LSTM]
    LSTM4[LSTM]
    LSTM5[LSTM]
    LSTM6[LSTM]
    i1[i1]
    i2[i2]
    i3[i3]
    o1[c]
    o2[a]
    o3[NULL]
    o4[t]
    o5[NULL]
    o6[NULL]
    i1--&amp;gt;LSTM1
    LSTM1--&amp;gt;o1
    i1--&amp;gt;LSTM2
    LSTM2--&amp;gt;o2
    i1--&amp;gt;LSTM3
    LSTM3--&amp;gt;o3
    i2--&amp;gt;LSTM4
    LSTM4--&amp;gt;o4
    i2--&amp;gt;LSTM5
    LSTM5--&amp;gt;o5
    i3--&amp;gt;LSTM6
    LSTM6--&amp;gt;o6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以當輸入的語音embedding長度為\(T\)時，我們就會在對應的答案裡面加入\(T\)個&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;，至於要如何將\(T\)個&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;放進去就跟CTC的方式相同。&lt;/p&gt;

&lt;p&gt;RNN-T除了predict方式的不同，還有在輸出的最後放一個language model，並把language model的輸出與下一個時間點的輸入一用餵進LSTM當中，可以看&lt;a href=&quot;https://youtu.be/CGuLuBaLIeI?t=1870&quot;&gt;影片中的架構&lt;/a&gt;來獲得比較清楚的了解。&lt;/p&gt;

&lt;p&gt;總的來說，RNN-T的架構如下圖，由三個部分所構成成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Encoder：可以想成是acoustic model，也就是上面架構圖中的LSTM，計算語音訊號的特徵。&lt;/li&gt;
  &lt;li&gt;Prediction Network：可以想成是language model，在&lt;a href=&quot;https://youtu.be/CGuLuBaLIeI?t=1870&quot;&gt;影片中的架構&lt;/a&gt;裡面最上層的部分。&lt;/li&gt;
  &lt;li&gt;Joint Network：綜合Encoder和Prediction Network的輸出決定最後的文字是什麼，在&lt;a href=&quot;https://youtu.be/CGuLuBaLIeI?t=1870&quot;&gt;影片中的架構&lt;/a&gt;中是黃色的框框。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.researchgate.net/publication/335044103/figure/fig3/AS:789632253952000@1565274408664/Recurrent-neural-network-RNN-transducer-structure-38.png&quot; alt=&quot;RNN-T Overview&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;neural-transducer&quot;&gt;Neural Transducer&lt;/h2&gt;

&lt;p&gt;Neural Transducer和RNN-T的作法類似，與RNN-T不同的地方在於，輸入從單一個acoustic feature變成多個acoustic feature，並在其中加入attention的機制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./neural_transducer_architecture.png&quot; alt=&quot;Neural Transducer Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在neural transducer裡，輸入進來的acoustic feature們會用固定大小\(W\)的window切開，分成多個block，每次模型會根據當前輸入的block中的acoustic feature來做predict，直到model predict出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;以後才會輸入下一個block。&lt;/p&gt;

&lt;h2 id=&quot;monotonic-chunkwise-attentionmocha&quot;&gt;Monotonic Chunkwise Attention（MoChA）&lt;/h2&gt;

&lt;p&gt;MoChA又對neural transducer做了一些變形，在neural transducer裡使用固定大小的\(W\)來對acoustic feature分塊，而MoChA想讓model來自己決定block要怎麼切。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./mocha_attention.png&quot; alt=&quot;MoChA Attention&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上圖(a)是一般的soft attention，在輸出\(y\)的時候會對所有的input算attention。&lt;/p&gt;

&lt;p&gt;圖(b)是monotonic attention，由model來決定要attend多少input，\(\otimes\)是有被選中的input，而\(\bullet\)是決定要停止的地方，下一個時間點會從上一個時間點停止的地方開始往後預測該要在哪個input停下來。&lt;/p&gt;

&lt;p&gt;圖(c)是MoChA，與圖(b)的作法類似，但在這邊會設定一個window size \(W\)，在停下來的地方往前框\(W\)個feature來當作模型的輸入，在圖中的例子是設定\(W=3\)。&lt;/p&gt;

&lt;h2 id=&quot;總結&quot;&gt;總結&lt;/h2&gt;

&lt;p&gt;在這篇文章裡面介紹了一些End-to-end的方式來訓練語音辨識的模型，它們的辨識錯誤率跟先前的HMM-DNN hybrid模型相近，如果資料量夠大的話，end-to-end的模型還可以把錯誤率再調降，可以根據擁有的資料量來決定要使用哪一種方式來製作你的語音辨識模型。&lt;/p&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=CGuLuBaLIeI&quot;&gt;[DLHLP 2020] Speech Recognition (3/7) - CTC, RNN-T and more&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1508.01211.pdf&quot;&gt;Listen, Attend and Spell&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/figure/Recurrent-neural-network-RNN-transducer-structure-38_fig3_335044103&quot;&gt;Figure 4 - available via license: Creative Commons Attribution 4.0 International&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1511.04868.pdf&quot;&gt;A Neural Transducer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1712.05382.pdf&quot;&gt;Monotonic Chunkwise Attention&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Speech-Recognition" /><summary type="html">在先前的文章裡頭，介紹了在深度學習蓬勃發展之前，語音辨識大概是如何達成的，而這篇文章會簡單介紹一下，在加入了深度學習以後，語音辨識的技術有了什麼樣的更動。</summary></entry><entry><title type="html">語音辨識概觀</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/06/14/introduction-to-speech-recognition/" rel="alternate" type="text/html" title="語音辨識概觀" /><published>2021-06-14T00:00:00+00:00</published><updated>2021-06-14T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/06/14/introduction-to-speech-recognition</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/06/14/introduction-to-speech-recognition/">&lt;p&gt;在我們的生活當中，語音辨識已經越來越普及了，不論是語音輸入、語音助手都有使用到語音辨識的技術，底下簡單介紹一下在大量使用neural network之前語音辨識所使用到的一些技術。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;基礎介紹&quot;&gt;基礎介紹&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR;
	waveform(&quot;Waveform (X)&quot;)
	word(&quot;Word (Y)&quot;)
	waveform--ASR System--&amp;gt;word
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;語音辨識（Automatic Speech Recognition, ASR）所做的事情如上圖所示，將輸入的訊號轉換成文字，亦即是去尋找&lt;/p&gt;

\[\arg\max\limits_Y P(Y\vert X)\]

&lt;h3 id=&quot;輸入&quot;&gt;輸入&lt;/h3&gt;

&lt;p&gt;關於ASR輸入的部分，在大多數的情況下，我們並不會直接將waveform當作輸入，而是會先對這個waveform做一些處理，最常見的做法是將waveform轉成MFCC sequence後再餵入ASR系統裡面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mel-frequency Cepstrum Coefficients (MFCC)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一般的設定當中，語音訊號的採樣頻率是16k，也就是1秒會有16k個數值，而&lt;a href=&quot;https://en.wikipedia.org/wiki/Mel-frequency_cepstrum&quot;&gt;MFCC&lt;/a&gt;會以25ms為一個window、每10ms為間隔去將25ms的音訊轉成39維的向量。概括來說MFCC做的事情是先將waveform過傅立葉轉換，再通過一群filter bank，最後從頻域轉回來，而這些filter bank是過去人們研究耳朵的構造所訂定出來的，專門為了辨識音訊所設計。&lt;/p&gt;

&lt;p&gt;MFCC具體上做的事情還蠻複雜的，好在現在可以直接使用&lt;a href=&quot;https://github.com/kaldi-asr/kaldi&quot;&gt;Kaldi&lt;/a&gt;幫我們將音訊轉成MFCC，只要將音訊餵進去，它就可以幫忙將音訊轉成MFCC sequence，也就是一堆39維的向量組成的序列，接著就可以開始製作ASR系統了。&lt;/p&gt;

&lt;p&gt;值得一提的是，近期有蠻多研究會直接使用過完filter bank以後得到的輸出當作ASR系統的輸入，可以看需求來選擇不同的feature，在Kaldi裡面都有支援。&lt;/p&gt;

&lt;h3 id=&quot;輸出&quot;&gt;輸出&lt;/h3&gt;

&lt;p&gt;在ASR系統輸出的部分，我們最終想要輸出的是文字，但在語音辨識裡面，通常ASR系統輸出的並不會直接是文字，而是比文字再更小的單位，因為一個字通常是由很多音來組成的，像是注音符號就是一個比文字再更小的單位，底下介紹一下常用的輸出有什麼。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Phoneme&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Phoneme是發音的最小單位，可以想像成是類似英文的音標，而這種輸出會需要有該語言的專業人士告訴我們每一個字所對應到的phoneme是什麼，好讓ASR系統在產生出phoneme以後，能藉由查表的方式轉換成文字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Graphme&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Graphme是書寫的最小單位，在英文的話會是英文字母，在中文的話會是每一個中文字，雖說中文字有上萬個，但實際上常用的中文字大概在3000-5000的量級。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Morpheme&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Morpheme是比graphme再大一點的單位，可以說是英文的字根字首。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unbelievable&lt;/code&gt;→&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;un&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;believe&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;able&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;hybrid-asr&quot;&gt;Hybrid ASR&lt;/h2&gt;

&lt;p&gt;接下來稍微講一下ASR系統該怎麼做，不過在做語音辨識之前，我們會要先去蒐集語音及其相對應的文字\(\mathcal{D}_l=\{(X_i, Y_i)\}^{N}_{i=1}\)，其中\(X=[x_1, ..., x_T]\in (\mathbb{R}^m)^*\)，\(x_t\)是一個\(m\)維的向量，可以想成是之前提到的MFCC，而\(Y=[y_1, ..., y_L] \in B^*\)，\(B\)代表的是文字的vocabulary，我們想要製作的ASR系統其實就是\(p_\theta(Y\vert X)\)，將音訊輸入進去以後，告訴我們文字出現的機率。&lt;/p&gt;

&lt;p&gt;這個章節想要提的hybrid ASR主要由三個部分組成：Language Model（LM）、Pronunciation Model（PM）、Acoustic Model（AM）。&lt;/p&gt;

&lt;h3 id=&quot;language-model&quot;&gt;Language Model&lt;/h3&gt;

&lt;p&gt;Language model做的事情是判斷這個文字序列\(Y\)出現的機率有多少，有點像是鍵盤輸入法的校正，隨著輸入的文字越來越長，去找最適當的文字該要是什麼，寫成數學式如下。&lt;/p&gt;

\[p_{LM}(Y)=\prod^L_{i=1}p(y_i\vert y_1, ..., y_{i-1})\]

&lt;h3 id=&quot;pronunciation-model&quot;&gt;Pronunciation Model&lt;/h3&gt;

&lt;p&gt;Pronunciation model其實就是前面所提到的，文字跟phoneme的對應表，又稱為lexicon。每一個\(Y\)，都可以根據這個表對應成phoneme sequence。&lt;/p&gt;

\[P=[p_1, ..., p_M]=f_{PM}(Y)\in O^*\]

&lt;p&gt;其中\(f_{PM}(Y)\)代表mapping function，\(O\)表示phoneme inventory，也就是所有的phoneme有哪些。&lt;/p&gt;

&lt;h3 id=&quot;acoustic-model&quot;&gt;Acoustic Model&lt;/h3&gt;

&lt;p&gt;Acoustic model做的事情是去決定phoneme sequence產生出\(X\)的機率，亦即\(p_{AM}(X\vert P)\)，而phoneme sequence當中的每一個phoneme \(p\)都有可能產生出不定長度的feature \(x\)，我們並不知道\(X=[x_1, ..., x_T]\)當中的哪些\(x_t\)是由哪個\(p_t\)產生的，為此，我們對於每一個phoneme都用一個&lt;a href=&quot;https://en.wikipedia.org/wiki/Hidden_Markov_model#Applications&quot;&gt;Hidden Markov Model（HMM）&lt;/a&gt;來model。&lt;/p&gt;

&lt;p&gt;可以想成是說，我們創造了另一個比phoneme更小的單位，HMM的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;，來代表一個phoneme，可能一個phoneme 是由3個state組成\(p_1=[a_1, a_2, a_3]\)，當\(X=[a_1, a_1, a_2, a_2, a_2, a_3]\)，我們就有機會可以說\(X\)是由phoneme \(p_1\)產生出來的，因此原先的phoneme sequence \(P\)，可以以HMM state來改寫成\(A=[a_1, ..., a_T]\)，這邊\(A\)的長度與\(X\)的長度一致，所以\(A\)又被稱之為alignment。&lt;/p&gt;

\[\begin{aligned} 
p_{AM}(X,A\vert P) &amp;amp; =p_{emit}(X\vert A)p_{tran}(A\vert P) \\
&amp;amp; =\prod\limits_t p_{emit}(x_t\vert a_t)p_{tran}(a_t\vert a_{t-1}; P)
\end{aligned}\]

&lt;p&gt;有了alignment以後，我們可以根據這些state來算出joint probability，上面的\(p_{tran}\)表示的是HMM當中的transition probability，而\(p_{emit}\)表示emission probability，亦即這個state產生出這個feature的機率，通常使用&lt;a href=&quot;https://scikit-learn.org/stable/modules/mixture.html&quot;&gt;Gaussian Mixture Model（GMM）&lt;/a&gt;來model。&lt;/p&gt;

&lt;p&gt;而實際上我們想要知道的\(p_{AM}(X\vert P)\)就是將所有有可能的\(A\)都加起來&lt;/p&gt;

\[\begin{aligned}
p_{AM}(X\vert P) &amp;amp; =\sum_A p_{emit}(X\vert A)p_{tran}(A\vert P) \\
&amp;amp; \approx \max_A p_{emit}(X\vert A)p_{train}(A\vert P)
\end{aligned}\]

&lt;p&gt;雖然在算式裡面有很多的\(\sum\)和\(\prod\)還有窮舉，其實在做計算的時候會使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm&quot;&gt;forward-backward algorithm&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Viterbi_algorithm&quot;&gt;Viterbi algorithm&lt;/a&gt;這些類似dynamic programming的方式來有效率的計算。&lt;/p&gt;

&lt;h3 id=&quot;組合hybrid-asr&quot;&gt;組合Hybrid ASR&lt;/h3&gt;

&lt;p&gt;前面介紹了hybrid ASR當中重要的三個部分：LM、PM、AM，而它們三個組合起來的方式如下&lt;/p&gt;

\[\begin{aligned}
p_\theta(X,Y) &amp;amp; = p_{AM}(X\vert f_{PM}(Y))p_{LM}(Y) \\
&amp;amp; = \sum_Ap_{emit}(X\vert A)p_{tran}(A\vert f_{PM}(Y))p_{LM}(Y) \\
&amp;amp; \approx \max_Ap_{emit}(X\vert A) p_{tran}(A\vert f_{PM}(Y))p_{LM}(Y)
\end{aligned}\]

&lt;p&gt;雖說它們存在於同一個數學式當中，但實際上LM和AM通常是會被分開訓練的，它們有各自的objective function。&lt;/p&gt;

\[p^*_{LM}=\arg\max\limits_{p_{LM}}\sum\limits^{N}\limits_{i=1}\log p_{LM}(Y_i)\]

\[p^*_{AM}=\arg\max\limits_{p_{AM}}\sum\limits^N\limits_{i=1}\log p_{AM}(X_i\vert f_{PM}(Y_i))\]

&lt;p&gt;在知道怎麼計算joint probability \(p_\theta(X,Y)\)以後，我們想要求得的\(\arg \max\limits_Y p_\theta(Y\vert X)\)就是去尋找最大的joint probability \(p_\theta(X,Y)\)。&lt;/p&gt;

\[\begin{aligned}
\arg\max\limits_Yp_\theta(Y\vert X) &amp;amp; = \arg\max\limits_Y\frac{p_\theta(X,Y)}{p(X)} \\
&amp;amp; \approx \arg\max\limits_Yp_\theta(X,Y)
\end{aligned}\]

&lt;p&gt;其中\(p(X)\)是語音\(X\)出現的機率，假設每一段語音出現的機率都均等的話，我們可以忽略不看。&lt;/p&gt;

&lt;p&gt;實際上在操作的時候，我們會將HMM emission probability、transition probability、lexicon和language model共同組成&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_transducer&quot;&gt;Weighted Finite State Transducers（WFST）&lt;/a&gt;，並從中去尋找最佳路徑，與此同時還會引入一個\(\alpha\)來去調配acoustic model和language model的平衡。&lt;/p&gt;

\[p_{\theta,\alpha}(X,Y)\propto p_{AM}(X\vert f_{PM}(Y))p_{LM}(Y)^\alpha\]

&lt;p&gt;而這個\(\alpha\)是在development set \(\{(\tilde X_i,\tilde Y_i)\}^{\tilde N}_{i=1}\)最小化edit distance得到的。&lt;/p&gt;

\[\alpha=\arg\min\limits_\alpha\sum\limits_{i=1}\limits^{\tilde N}ED\left ( \tilde Y_i,\arg\max\limits_Y \left (\log p_{AM}(\tilde X\vert f_{PM}(Y))+ \alpha*\log p_{LM}(Y)\right ) \right )\]

&lt;p&gt;所以最終語音辨識出來的文字會是&lt;/p&gt;

\[Y^*=\arg\max\limits_Yp_{\theta,\alpha}(X,Y)\]

&lt;h3 id=&quot;在hybrid-asr裡面使用dnn&quot;&gt;在Hybrid ASR裡面使用DNN&lt;/h3&gt;

&lt;p&gt;隨著neural network的興起，語音辨識也逐漸引入deep learning來幫助辨識，在這個hybrid ASR系統裡面，我們也可以使用DNN來幫助我們提高辨識率。&lt;/p&gt;

&lt;p&gt;在acoustic model裡面，我們想要算的是\(p_{AM}(X\vert P)\)，在前面的推導當中，我們得到&lt;/p&gt;

\[p_{AM}(X\vert P)\approx \max_A p_{emit}(X\vert A)p_{tran}(A\vert P)\]

&lt;p&gt;其中再去細鑽下去的話&lt;/p&gt;

\[\begin{aligned}
p_{AM}(X\vert P) &amp;amp; \approx \max_A p_{emit}(X\vert A)p_{tran}(A\vert P) \\
&amp;amp; = \max\limits_A\prod\limits^T\limits_{t=1}p_{emit}(x_t\vert a_t)p_{tran}(a_t\vert a_{t-1}; P) \\
&amp;amp; = \max\limits_A\prod\limits^T\limits_{t=1}\frac{p(a_t\vert x_t)p(x_t)}{p(a_t)}p_{tran}(a_t\vert a_{t-1}; P)
\end{aligned}\]

&lt;p&gt;其中\(p_{tran}(a_t\vert a_{t-1}; P)\)一樣是由HMM來，\(p(a_t)\)可以從HMM裡面統計出來\(p(a_t)=\frac{a_t出現的次數}{所有state出現的次數}\)，而\(p(a_t\vert x_t)\)就可以用DNN來做訓練。&lt;/p&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=AIKu43goh-8&quot;&gt;[DLHLP 2020] Speech Recognition (1/7) - Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/2105.11084&quot;&gt;Unsupervised Speech Recognition&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Speech-Recognition" /><summary type="html">在我們的生活當中，語音辨識已經越來越普及了，不論是語音輸入、語音助手都有使用到語音辨識的技術，底下簡單介紹一下在大量使用neural network之前語音辨識所使用到的一些技術。</summary></entry><entry><title type="html">在Google Sheet裡面呈現html</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/06/05/display-html-in-google-sheet/" rel="alternate" type="text/html" title="在Google Sheet裡面呈現html" /><published>2021-06-05T00:00:00+00:00</published><updated>2021-06-05T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/06/05/display-html-in-google-sheet</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/06/05/display-html-in-google-sheet/">&lt;p&gt;前陣子有人推薦了一個好用的資料呈現套件&lt;a href=&quot;https://plotly.com/&quot;&gt;plotly&lt;/a&gt;，這個套件可以將結果輸出成html讓使用者與之互動，這邊紀錄一下如何將html呈現在Google Sheet裡面，讓我們不用再找一個地方存放這個html。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;具體實現的方法是建立一個Google Apps Script，並綁定Google Sheet上面的物件，讓使用者跟這個物件互動的時候跳出一個Dialog擺html來跟使用者互動，底下會詳述各個步驟該如何設定。&lt;/p&gt;

&lt;h2 id=&quot;google-apps-script&quot;&gt;Google Apps Script&lt;/h2&gt;

&lt;p&gt;首先先打開Google Sheet，並在工具的地方按下Script editor。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./script_editor.png&quot; alt=&quot;Script Editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按下去以後會跳出新的分頁，在這裡可以寫一些程式碼來去與Google的服務做互動。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./new_app_script.png&quot; alt=&quot;New App Script&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在這邊我們將底下的程式碼貼到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code.gs&lt;/code&gt;的檔案裡面，記得將&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;YOUR_HTML_FILENAME&amp;gt;&lt;/code&gt;替換成你html的檔名、想一個要顯示在Dialog的名稱替換掉&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;TITLE_OF_DIALOG&amp;gt;&lt;/code&gt;。目前設定跳出來的Dialog的大小是1000*1000，可以根據你想要顯示的大小做調整。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;openDialog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HtmlService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createHtmlOutputFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;lt;YOUR_HTML_FILENAME&amp;gt;&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setSandboxMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;HtmlService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SandboxMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;NATIVE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;SpreadsheetApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getUi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;showModalDialog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;lt;TITLE_OF_DIALOG&amp;gt;&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最後在檔案旁邊的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;號點選新增html，並將你想要呈現的html貼在裡面並按下旁邊的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Save project&lt;/code&gt;就完成這個部分了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./new_html.png&quot; alt=&quot;New html&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./save_project.png&quot; alt=&quot;Save Project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;記得新增的html名稱要跟程式碼裡面寫的一致。&lt;/p&gt;

&lt;h2 id=&quot;綁定google-sheet物件&quot;&gt;綁定Google Sheet物件&lt;/h2&gt;

&lt;p&gt;首先，我們要先創建一個物件讓使用者跟它做互動，這邊我們自己畫一個像按鈕的圖樣。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./new_drawing.png&quot; alt=&quot;New Drawing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./drawing_example.png&quot; alt=&quot;Draw Example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;建立好物件後，點選右上角的三個點，選擇&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Assign script&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assign_script_dropdown.png&quot; alt=&quot;Assign Script&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在跳出的視窗填上剛剛程式碼中的function名稱&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openDialog&lt;/code&gt;後按下OK。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assign_script_popup.png&quot; alt=&quot;Assign Script&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到這邊就全部設定完成了！之後使用者點選物件就會跳出你製作的html。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./result.gif&quot; alt=&quot;Result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得一提的是，在使用者第一次點選的時候，應該會跳出像底下的權限要求，照著提示准許就行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./authorization.png&quot; alt=&quot;Authorization&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果之後想要移動物件位置的話，對物件按滑鼠右鍵即可。&lt;/p&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quora.com/How-do-I-add-HTML-code-in-a-Google-Spreadsheet-Cell&quot;&gt;How do I add HTML code in a Google Spredsheet Cell&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Tool" /><summary type="html">前陣子有人推薦了一個好用的資料呈現套件plotly，這個套件可以將結果輸出成html讓使用者與之互動，這邊紀錄一下如何將html呈現在Google Sheet裡面，讓我們不用再找一個地方存放這個html。</summary></entry><entry><title type="html">如何利用Swift製作倒數計時器</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/05/24/swift-menu-bar-timer/" rel="alternate" type="text/html" title="如何利用Swift製作倒數計時器" /><published>2021-05-24T00:00:00+00:00</published><updated>2021-05-24T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/05/24/swift-menu-bar-timer</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/05/24/swift-menu-bar-timer/">&lt;p&gt;先前都有在使用Mac app來幫我在電腦上倒計時，但有些功能需要付費才可以解鎖，剛好附近有人有在弄Mac app，想說自己來寫一個&lt;a href=&quot;https://github.com/wjohn1483/NLUTimer&quot;&gt;倒數計時器&lt;/a&gt;，在這邊紀錄一下製作的過程。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;安裝xcode&quot;&gt;安裝Xcode&lt;/h2&gt;

&lt;p&gt;工欲善其事必先利其器，在開始寫app之前，需要先安裝Apple的Xcode，可以直接去App Store裡面下載，只不過要先空下電腦裡面30GB的空間才可以下載，雖然我自己看安裝完成只佔了10GB左右。&lt;/p&gt;

&lt;h2 id=&quot;創建project&quot;&gt;創建Project&lt;/h2&gt;

&lt;p&gt;在前面的部分主要是參考&lt;a href=&quot;https://medium.com/@acwrightdesign/creating-a-macos-menu-bar-application-using-swiftui-54572a5d5f87&quot;&gt;這篇教學&lt;/a&gt;來設定好project，並弄出最基本的框架，如果覺得底下的步驟看不太懂的話，建議看看這篇教學。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;點選File→New→Project&lt;/li&gt;
  &lt;li&gt;選擇&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;App&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;設定project名稱&lt;/li&gt;
  &lt;li&gt;Interface選擇&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SwiftUI&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Language選擇&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Swift&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;選定project存放的位置以後按下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;執行完上面的步驟以後就完成了基本的project設定了，接下來就可以開始著手建造自己的app。&lt;/p&gt;

&lt;h2 id=&quot;製作popover&quot;&gt;製作Popover&lt;/h2&gt;

&lt;p&gt;在創建好project以後，Xcode會自動先生成兩個&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.swift&lt;/code&gt;檔，分別是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppDelegate.swift&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContentView.swift&lt;/code&gt;，我的理解是，程式執行時，會先執行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppDelegate.swift&lt;/code&gt;裡面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationDidFinishLaunching()&lt;/code&gt;，而在該function裡面會去new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContentView&lt;/code&gt;的物件來展示畫面給使用者，可以想成是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContentView.swift&lt;/code&gt;是用來刻UI，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppDelegate.swift&lt;/code&gt;用來實作feature。&lt;/p&gt;

&lt;p&gt;而在這邊我想要做的是像底下的popover，點選menu bar上面的icon以後，跳出一個視窗讓使用者輸入時間，所以預設的大部分程式碼都可以先刪除。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./input_textfield.png&quot; alt=&quot;Popover&quot; /&gt;&lt;/p&gt;

&lt;p&gt;為了創建popover我們會需要宣告一個&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSPopover&lt;/code&gt;的物件，一個簡單的例子如下&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cocoa&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SwiftUI&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;@NSApplicationMain&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AppDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSApplicationDelegate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSPopover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;applicationDidFinishLaunching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;aNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Create the SwiftUI view that provides the window contents.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;contentView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Create the popover&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;popover&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSPopover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transient&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSHostingController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rootView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的例子裡面，我們將&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contentView&lt;/code&gt;放進popover裡頭，所以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContentView.swift&lt;/code&gt;裡面刻的UI就會顯示在popover裡面了。&lt;/p&gt;

&lt;h2 id=&quot;製作menu-bar-item&quot;&gt;製作Menu Bar Item&lt;/h2&gt;

&lt;p&gt;在設定好popover該顯示的東西以後，我們還需要將一個按鈕放到Mac的menu bar上面，讓使用者點選這個按鈕以後跳出popover。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cocoa&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SwiftUI&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;@NSApplicationMain&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AppDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSApplicationDelegate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSPopover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;statusBarItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSStatusItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;applicationDidFinishLaunching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;aNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Create the SwiftUI view that provides the window contents.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;contentView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Create the popover&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;popover&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSPopover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transient&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSHostingController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rootView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// Create the status item&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statusBarItem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSStatusBar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;statusItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;withLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CGFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSStatusItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variableLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statusBarItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;named&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Icon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;#selector(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;togglePopover(_:)&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;@objc&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;togglePopover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AnyObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statusBarItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isShown&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;performClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;relativeTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;preferredEdge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSRectEdge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;minY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的程式碼裡面，我們建立了一個按鈕並設定它被點擊的時候呼叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tooglePopover()&lt;/code&gt;這個函式，而在該函式裡面會去顯示/隱藏popover。另外，在創建按鈕的時候有設定它顯示的圖片，設定的方式請參考下面的章節。&lt;/p&gt;

&lt;h2 id=&quot;引入圖片至project&quot;&gt;引入圖片至Project&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;點選&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Assets.xcassets&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在跳出的畫面左下角有個&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;的符號&lt;/li&gt;
  &lt;li&gt;設定圖片的名稱，這個名稱需要跟程式碼裡頭的一致&lt;/li&gt;
  &lt;li&gt;在右邊的側欄裡面可以設定圖片的一些屬性，如果是要放在menu bar的圖示的話，可以參考&lt;a href=&quot;https://medium.com/@acwrightdesign/creating-a-macos-menu-bar-application-using-swiftui-54572a5d5f87&quot;&gt;教學&lt;/a&gt;裡面的&lt;strong&gt;Createing a Menu Bar Icon&lt;/strong&gt;的設定。&lt;/li&gt;
  &lt;li&gt;將圖片拖曳到Xcode裡面的方框中就完成了&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;在dock裡面隱藏app&quot;&gt;在Dock裡面隱藏App&lt;/h2&gt;

&lt;p&gt;由於想要做的是menu bar app，不希望程式在執行的時候在dock也出現圖示，這時可以去&lt;strong&gt;Info.plist&lt;/strong&gt;裡面加入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application is agent (UIElement)&lt;/code&gt;這個參數並將value設成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YES&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;至此，一個簡單的popover app就完成了，底下會簡單介紹一下在製作倒數計時器的時候用到的一些東西，如果想看完整的程式碼，可以參考&lt;a href=&quot;https://github.com/wjohn1483/NLUTimer&quot;&gt;最後完成的成品&lt;/a&gt;，或許可以解決部分你遇到的問題。&lt;/p&gt;

&lt;h2 id=&quot;swift-timer&quot;&gt;Swift Timer&lt;/h2&gt;

&lt;p&gt;我所製作的倒數計時器主要是使用Swift的Timer這個class來完成主要的功能，Timer會根據使用者指定的時間固定去執行設定好的函式，詳細的介紹可以參考&lt;a href=&quot;https://www.hackingwithswift.com/articles/117/the-ultimate-guide-to-timer&quot;&gt;這篇教學&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Timer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scheduledTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;withTimeInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;repeats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Your function here&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的程式碼裡面，我們製作了一個Timer，它每過一秒就會執行大括號裡面的程式碼。&lt;/p&gt;

&lt;p&gt;如果想要讓這個Timer停下來，不再每秒執行，只需要呼叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invalidate()&lt;/code&gt;即可。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;invalidate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;值得一提的是，Timer一旦被invalidate以後，如果未來還想要它繼續執行的話，就得要重新製作一個Timer，不能重複利用，建議將創建Timer弄成一個function以方便快速的建立。&lt;/p&gt;

&lt;h2 id=&quot;為app建立global-shortcut&quot;&gt;為App建立Global Shortcut&lt;/h2&gt;

&lt;p&gt;在Swift裡面好像沒有可以直接設定global shortcut的方法，讓你能在任意視窗按下設定好的快捷鍵就打開你所寫的app，好在網路上有很多大神有做了好用的package，只要加進去project裡面就能簡單做到了，在這裡我所使用的是&lt;a href=&quot;https://github.com/sindresorhus/KeyboardShortcuts&quot;&gt;KeyboardShortcuts&lt;/a&gt;這個套件。&lt;/p&gt;

&lt;h3 id=&quot;swift-package-manager&quot;&gt;Swift Package Manager&lt;/h3&gt;

&lt;p&gt;將套件加入project的方式還蠻簡單的，點選menu bar的File→Swift Packages→Add Package Dependency…，在跳出的視窗貼上package GitHub repository的網址，最後按下確認就可以了。&lt;/p&gt;

&lt;h3 id=&quot;keyboardshortcuts&quot;&gt;KeyboardShortcuts&lt;/h3&gt;

&lt;p&gt;在引入好KeyboardShortcuts以後，只需要使用下面的程式碼就能設定好global shortcut了。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;KeyboardShortcuts&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;KeyboardShortcuts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;toggleUnicornMode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;togglePopover&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;modifiers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;@main&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AppDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSApplicationDelegate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;applicationDidFinishLaunching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;aNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Set shortcut action&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;KeyboardShortcuts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onKeyUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;togglePopover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Your function here&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在extension的部分，我們設定快捷鍵為command+option+k，並觸發&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;togglePopover&lt;/code&gt;這個名字的function。&lt;/p&gt;

&lt;p&gt;在app運行的時候我們還需要去綁定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;togglePopover&lt;/code&gt;這個名字實際上是去連接到哪一個function，也就是設定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyboardShortcuts.onKeyUp()&lt;/code&gt;的部分。&lt;/p&gt;

&lt;h2 id=&quot;在app內播放音樂&quot;&gt;在App內播放音樂&lt;/h2&gt;

&lt;h3 id=&quot;將音樂引入project&quot;&gt;將音樂引入project&lt;/h3&gt;

&lt;p&gt;直接從Finder裡面將音檔拖曳到Xcode左邊側欄的檔案列表就行了。&lt;/p&gt;

&lt;h3 id=&quot;播放音樂&quot;&gt;播放音樂&lt;/h3&gt;

&lt;p&gt;這邊使用Swift內建的套件來達成。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AVFoundation&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Import sound file&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;bundle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;forResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SOUND_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ofType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SOUND_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Found sound file&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;audioPlayer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AVAudioPlayer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;contentsOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;fileURLWithPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Sound file not found&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Play music audioPlayDefaultCount+1 times&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;audioPlayer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfLoops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audioPlayDefaultCount&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;audioPlayer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;audioPlayer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;play&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;audioPlayer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在import sound file的部分需要將&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOUND_PATH&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOUND_TYPE&lt;/code&gt;替換掉，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOUND_PATH&lt;/code&gt;就是音檔的名稱，但不包含副檔名，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOUND_TYPE&lt;/code&gt;是音檔的副檔名，像是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.wav&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;在使用時可以透過&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;numberOfLoops&lt;/code&gt;設定音樂要播幾次，音樂會播你所設定的數字加一次，所以如果只想播一次的話，可以不寫這行或是將數字設成0，如果是負數的話就會不斷循環播放不停止。&lt;/p&gt;

&lt;p&gt;在上面的例子裡面有將&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTime&lt;/code&gt;設為0，其原因是當我們呼叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop()&lt;/code&gt;以後，下次在呼叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;play()&lt;/code&gt;時，會從上次停止的地方再開始播放，如果想要從頭播放的話，就需要將&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTime&lt;/code&gt;設成0。&lt;/p&gt;

&lt;h2 id=&quot;傳送通知&quot;&gt;傳送通知&lt;/h2&gt;

&lt;p&gt;如果想要讓app發出系統通知顯示在螢幕的右上角，可以參考底下的程式碼，只需要修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;title&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;informativeText&lt;/code&gt;就能決定顯示在通知裡面的文字訊息。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;notification&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSUserNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Time&apos;s Up !!!&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;informativeText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Click notification to dismiss&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;soundName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSUserNotificationDefaultSoundName&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;NSUserNotificationCenter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;deliver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想要讓使用者點選通知以後觸發某個動作，這時需要一個繼承了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSUserNotificationCenterDelegate&lt;/code&gt;的class，並override &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;userNotificationCenter&lt;/code&gt;這個函式，最後在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSUserNotificationCenter&lt;/code&gt;綁定這個class的instance。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NLUTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSUserNotificationCenterDelegate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;showNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;notification&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSUserNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Time&apos;s Up !!!&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;informativeText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Click notification to dismiss&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;soundName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSUserNotificationDefaultSoundName&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasActionButton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;NSUserNotificationCenter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Binding this instance&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;NSUserNotificationCenter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;deliver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;userNotificationCenter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSUserNotificationCenter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;didActivate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSUserNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Click notification&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Do what you want here&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// Close notification&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;NSUserNotificationCenter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;removeAllDeliveredNotifications&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;輸出成app的格式&quot;&gt;輸出成.app的格式&lt;/h2&gt;

&lt;p&gt;在完成了project的所有功能以後，Xcode有提供打包成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.app&lt;/code&gt;的功能，方便開發者分享給其他使用者。&lt;/p&gt;

&lt;p&gt;只需要在Xcode的menu bar點選Product→Archive，在跳出的視窗選擇Distribute App→Copy App，最後選擇輸出的路徑就可以了。&lt;/p&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@acwrightdesign/creating-a-macos-menu-bar-application-using-swiftui-54572a5d5f87&quot;&gt;Create a macOS Menu Bar Application Using SwiftUI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/articles/117/the-ultimate-guide-to-timer&quot;&gt;The ultimate guide to Timer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Swift" /><summary type="html">先前都有在使用Mac app來幫我在電腦上倒計時，但有些功能需要付費才可以解鎖，剛好附近有人有在弄Mac app，想說自己來寫一個倒數計時器，在這邊紀錄一下製作的過程。</summary></entry><entry><title type="html">Deep Interest Evolution Network for Click-Through Rate Prediction</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/03/21/deep-interest-evolution-network-for-click-through-rate-prediction/" rel="alternate" type="text/html" title="Deep Interest Evolution Network for Click-Through Rate Prediction" /><published>2021-03-21T00:00:00+00:00</published><updated>2021-03-21T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/03/21/deep-interest-evolution-network-for-click-through-rate-prediction</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/03/21/deep-interest-evolution-network-for-click-through-rate-prediction/">&lt;p&gt;簡單記錄一下，看完此篇paper的筆記。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1809.03672.pdf&quot;&gt;這篇paper&lt;/a&gt;是由阿里巴巴提出來，利用使用者的行為和基本資訊，來去預測使用者對廣告的CTR，榮獲AAAI 2019 accepted paper。&lt;/p&gt;

&lt;h2 id=&quot;dien&quot;&gt;DIEN&lt;/h2&gt;

&lt;p&gt;在這篇paper當中，作者將他們的model稱之為DIEN（Deep Interest Evolution Network），其架構如下圖。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./model_architecture.png&quot; alt=&quot;Model Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到在架構圖中右下方的地方，有三個輸入，分別是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Target Ad&lt;/strong&gt;：被預測的廣告embedding&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context Feature&lt;/strong&gt;：這個feature我沒有看得很懂，從paper的原文裡面說是時間以及其他的東西&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UserProfile Feature&lt;/strong&gt;：使用者的embedding，包含性別、年齡等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;左方的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b(1)、b(2)、b(T-1)、b(T)&lt;/code&gt;是使用者行為，像是使用者點過什麼廣告，經過&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Embedding Layer&lt;/code&gt;以後稱之為&lt;strong&gt;behavior feature&lt;/strong&gt;，之後這些feature會被餵到&lt;a href=&quot;#interest-extractor-layer&quot;&gt;Interest Extractor Layer&lt;/a&gt;和&lt;a href=&quot;#interest-evolving-layer&quot;&gt;Interest Evolving Layer&lt;/a&gt;，最終產生一個embeeding \(h&apos;(T)\)。&lt;/p&gt;

&lt;p&gt;最後\(h&apos;(T)\)會與右方的&lt;strong&gt;Target Ad&lt;/strong&gt;、&lt;strong&gt;Context Feature&lt;/strong&gt;和&lt;strong&gt;UserProfile Feature&lt;/strong&gt;一同串起來，經過一些fully connected layers以後，產生出2維的輸出（點、不點），並利用binary cross entropy來當作loss function。&lt;/p&gt;

\[L_{target}=-\frac{1}{N}\sum\limits^{N}\limits_{(\textbf{x},y)\in\mathcal{D}}(y\log p(\textbf{x})+(1-y)\log (1-p(\textbf{x})))\]

&lt;h3 id=&quot;interest-extractor-layer&quot;&gt;Interest Extractor Layer&lt;/h3&gt;

&lt;p&gt;在Interest Extractor Layer裡面會去將使用者行為透過GRU製作成feature，在這邊作者使用的是使用者廣告的點擊來當作使用者行為，也就是照著時間順序將使用者點擊的廣告的embedding餵入GRU中，值得一提的是，作者將GRU的輸出額外拉出來做auxiliary loss，來幫助GRU訓練得更好。&lt;/p&gt;

&lt;h4 id=&quot;auxiliary-loss&quot;&gt;Auxiliary Loss&lt;/h4&gt;

&lt;p&gt;在每一個時間點\(t\)，GRU會產生一個輸出\(h(t)\)，這時會將使用者下一個時間點\(t+1\)點擊的廣告embedding \(e(t+1)\)拿出來，接著從眾多廣告embedding中隨機取樣一個沒有點擊的出來作為\(e(t+1)\prime\)，並將有點擊的label成\(1\)，沒點擊的label成\(0\)來做訓練，藉此來讓\(h(t)\)更能含有可以預測出下一個點擊的資訊。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR;
    gru(&quot;h(t)&quot;)
    sig1[&quot;Sigmoid&quot;]
    sig2[&quot;Sigmoid&quot;]
    pos(&quot;e(t+1)&quot;)
    neg(&quot;e(t+1)&apos;&quot;)
    label1((1))
    label0((0))
    pos--&amp;gt;sig1;
    gru--&amp;gt;sig1;
    sig1--&amp;gt;label1;
    gru--&amp;gt;sig2;
    sig2--&amp;gt;label0;
    neg--&amp;gt;sig2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整體的loss fcuntion因此會變成&lt;/p&gt;

\[L=L_{target}+\alpha*L_{aux}\]

\[L_{aux}=-\frac{1}{N}\left( \sum\limits_{i=1}\limits^{N} \sum\limits_{t}\log\sigma(\textbf{h}^i_t,\textbf{e}^i_b[t+1])+\log(1-\sigma(\textbf{h}^i_t,\hat{\textbf{e}^i_b}[t+1]))\right )\]

&lt;h3 id=&quot;interest-evolving-layer&quot;&gt;Interest Evolving Layer&lt;/h3&gt;

&lt;p&gt;使用者可能同時間表現出多種興趣，而我們比較想要知道的是使用者對某特定廣告的興趣有多少，所以在這邊作者加了Interest Evolving Layer，亦即另一層GRU，來去從使用者行為當中萃取出相對應廣告的興趣。&lt;/p&gt;

&lt;p&gt;作者使用的方式是利用attention的機制，透過目標廣告的embedding與Interest Extractor Layer出來的embeeding做相似度的計算&lt;/p&gt;

\[a_t=\frac{\exp(\textbf{h}_tW\textbf{e}_a)}{\sum\limits_{j=1}\limits^{T}\exp(\textbf{h}_jW\textbf{e}_a)}\]

&lt;p&gt;並利用各種不同的方式將這個attention weight融入至GRU中。&lt;/p&gt;

&lt;h4 id=&quot;gru-with-attentional-input-aigru&quot;&gt;GRU with attentional input (AIGRU)&lt;/h4&gt;

&lt;p&gt;第一種方式是直接將Interest Extractor Layer的輸出\(\textbf{h}_t\)直接乘上attention weight \(a_t\)，然後輸入至Interest Evolving Layer中。&lt;/p&gt;

\[\textbf{i}&apos;_t=\textbf{h}_t*a_t\]

&lt;h4 id=&quot;attention-based-gru-agru&quot;&gt;Attention based GRU (AGRU)&lt;/h4&gt;

&lt;p&gt;第二種方式是透過算出來的attention weight來決定Interest Evolving Layer中hidden state \(\textbf{h}&apos;_t\)要被更新多少。&lt;/p&gt;

\[\textbf{h}&apos;_t=(1-a_t)*\textbf{h}&apos;_{t-1}+a_t*\tilde{\textbf{h}&apos;_t}\]

&lt;p&gt;其中\(\textbf{h}&apos;_{t-1}\)是前一個時間點，Interest Evolving Layer的輸出，而\(\tilde{\textbf{h}&apos;_t}\)是當下這個時間點\(t\)，GRU內部所計算出來的hidden state，可以參照原先GRU的更新算式，或是&lt;a href=&quot;https://arxiv.org/pdf/1809.03672.pdf&quot;&gt;paper當中的式(2)~式(5)&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;gru-with-attentional-update-gate-augru&quot;&gt;GRU with attentional update gate (AUGRU)&lt;/h4&gt;

&lt;p&gt;第三種方式是將update gate的值與attention weight相乘，直接控制update gate，這個方式也是實驗當中表現最好的方式。&lt;/p&gt;

\[\tilde{\textbf{u}}&apos;_t=a_t*\textbf{u}&apos;_t\]

\[\textbf{h}&apos;_t=(1-\tilde{\textbf{u}}&apos;_t)\circ\textbf{h}&apos;_{t-1}+\tilde{\textbf{u}}&apos;_t\circ\tilde{\textbf{h}}&apos;_t\]

&lt;h2 id=&quot;experiments&quot;&gt;Experiments&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;public_dataset_auc.png&quot; alt=&quot;Public Dataset AUC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將DIEN套用在&lt;a href=&quot;https://arxiv.org/pdf/1809.03672.pdf#cite.mcauley2015image&quot;&gt;Amazon Dataset&lt;/a&gt;上面可以看到，DIEN的AUC是裡面最佳的，而作者有將這個model套用在企業的資料上，也獲得了不俗的成績。&lt;/p&gt;

&lt;p&gt;在paper裡面實驗的章節中作者做了許多的實驗來去驗證model裡面的每一個環節都是有必要的，有興趣的人可以去看看原本的paper。&lt;/p&gt;

&lt;h2 id=&quot;結論&quot;&gt;結論&lt;/h2&gt;

&lt;p&gt;在這篇paper裡面，作者提出了有點類似wide and deep架構的模型來去解CTR prediction的問題，也加入了各式各樣的方式來應用attention weight，只不過在實驗當中只有展示Electronics和Books這兩個類別的成效，如果可以加入不同類別的比較我覺得可以讓讀者了解model適合套用在哪種類別的場景當中會更好。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="Paper" /><summary type="html">簡單記錄一下，看完此篇paper的筆記。</summary></entry><entry><title type="html">利用GitHub Actions來部署部落格</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/02/28/move-blog-to-github-actions/" rel="alternate" type="text/html" title="利用GitHub Actions來部署部落格" /><published>2021-02-28T00:00:00+00:00</published><updated>2021-02-28T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/02/28/move-blog-to-github-actions</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/02/28/move-blog-to-github-actions/">&lt;p&gt;前陣子發現到GitHub Actions可以用來做CI，試著使用看看。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;github-actions&quot;&gt;GitHub Actions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/features/actions&quot;&gt;GitHub Actions&lt;/a&gt;是GitHub自己出的一套CI/CD的工具，可以讓你在推code、看CI/CD都在GitHub上面解決。&lt;/p&gt;

&lt;p&gt;GitHub Actions相較於其他CI/CD的工具，我覺得它的優勢在於免費的額度比較多，如果是public repository，actions的使用是免費的，而private repository每個月也有2000分鐘的使用時間，而且如果有其他人fork你的repository，這些CI/CD的設定也會跟著被帶走，別人也可以無痛的使用相同的CI/CD流程。&lt;/p&gt;

&lt;h2 id=&quot;開始使用github-actions&quot;&gt;開始使用GitHub Actions&lt;/h2&gt;

&lt;p&gt;只要在repository裡面創建&lt;strong&gt;.github/workflows/&lt;/strong&gt;，並在裡面放好設定檔，就可以觸發GitHub Actions了，你也可以在repository頁面的上方點Actions的頁籤，裡面有一些設定檔的範本可以選擇。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;My first github actions&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;branches&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Build&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;runs-on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ubuntu-latest&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Checkout&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/checkout@v2&lt;/span&gt;

      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Build&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;echo &quot;hello&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;設定檔跟其他的工具長相差不多，在steps裡面填寫你想要做的事情，GitHub就會起一個virtual machine來執行。&lt;/p&gt;

&lt;h2 id=&quot;設定環境變數&quot;&gt;設定環境變數&lt;/h2&gt;

&lt;p&gt;如果想要在Actions裡面傳入環境變數的話，可以參考底下的步驟。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD;
	A(點選Repository右上角的Settings)
	B(點選左下角的Secrets)
	C(點選右上角的New repository secret)
	D(打上環境變數的名稱以及值)
    A--&amp;gt;B;
    B--&amp;gt;C;
    C--&amp;gt;D;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;repository裡面設定好環境變數以後，在設定檔需要宣告使用哪些環境變數，之後在steps裡面就可以直接使用了。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;My first github actions&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;branches&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    
&lt;span class=&quot;na&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Build&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;USER_NAME&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${{secrets.USER_NAME}}&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;runs-on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ubuntu-latest&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Checkout&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/checkout@v2&lt;/span&gt;

      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Build&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;echo &quot;${USER_NAME}&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;想要在actions裡面push程式碼到repository&quot;&gt;想要在Actions裡面push程式碼到repository&lt;/h2&gt;

&lt;p&gt;在Actions裡面有人寫好了&lt;a href=&quot;https://github.com/marketplace/actions/webfactory-ssh-agent&quot;&gt;工具&lt;/a&gt;可以讓你宣告ssh key，就能像一般利用ssh key push的方式推程式碼到你的repository裡面，產生和設定ssh public/private key的方式請參考&lt;a href=&quot;https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh&quot;&gt;GitHub的官方文件&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在GitHub設定好public key以後，將private key弄到ssh-agent的方式可以參考底下。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;My first github actions&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;branches&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    
&lt;span class=&quot;na&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Build&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;USER_NAME&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${{secrets.USER_NAME}}&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;runs-on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ubuntu-latest&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Checkout&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/checkout@v2&lt;/span&gt;
        
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;webfactory/ssh-agent@v0.5.0&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;ssh-private-key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${{secrets.SSH_PRIVATE_KEY}}&lt;/span&gt;

      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Build&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;echo &quot;${USER_NAME}&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@JainKai/%E6%B7%BA%E8%AB%87-%E7%94%A8github-actions-%E7%B0%A1%E6%98%93%E7%9A%84-ci-%E4%BE%86%E7%99%BC%E5%B8%83gitpages-6ae48e52467e&quot;&gt;[淺談]用GitHub Actions 簡易的 CI 來發布GitPages&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/thinkthenrant/githubactionsintro-94be66a8a9f1&quot;&gt;帶著走的CI/CD：GitHub Actions! (Take the CI/CD with you: GitHub Actions!)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;webfactory/ssh-agent&quot;&gt;webfactory/ssh-agent&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Tool" /><summary type="html">前陣子發現到GitHub Actions可以用來做CI，試著使用看看。</summary></entry><entry><title type="html">利用Gitalk在靜態網頁裡面新增留言區</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/02/07/gitalk-introduction/" rel="alternate" type="text/html" title="利用Gitalk在靜態網頁裡面新增留言區" /><published>2021-02-07T00:00:00+00:00</published><updated>2021-02-07T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/02/07/gitalk-introduction</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/02/07/gitalk-introduction/">&lt;p&gt;先前在設定檔裡面發現這個部落格主題可以開啟留言的功能，這邊簡單介紹一下其背後所使用的Gitalk以及如何設定它。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;gitalk&quot;&gt;Gitalk&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt;是一個使用GitHub issue來當作留言板的工具，讓使用者們可以簡單的在他們的網頁上面安插一些javascript就可以做到留言板的效果，還可以支援Markdown語法，可以看&lt;a href=&quot;https://gitalk.github.io/&quot;&gt;官方的demo&lt;/a&gt;來感受成品大概長什麼樣子。&lt;/p&gt;

&lt;h2 id=&quot;套用在部落格上&quot;&gt;套用在部落格上&lt;/h2&gt;

&lt;p&gt;在jekyll的主題，&lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme&quot;&gt;jekyll-TeXt-theme&lt;/a&gt;裡面，已經有內建好可以搭配Gitalk使用，只是需要一些前置步驟並修改一下設定。&lt;/p&gt;

&lt;h3 id=&quot;建立github-application&quot;&gt;建立GitHub Application&lt;/h3&gt;

&lt;p&gt;為了要讓Gitalk可以直接在GitHub上面幫你留言，我們需要建立一個GitHub Application，讓Gitalk以&lt;a href=&quot;https://wjohn1483.github.io/2021/01/26/security-introduction/#oauth&quot;&gt;OAuth&lt;/a&gt;的方式代替你去GitHub上的issue留言，創建一個Application可以點&lt;a href=&quot;https://github.com/settings/applications/new&quot;&gt;這邊&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Application name：應用程式的名字，可以隨意取&lt;/li&gt;
  &lt;li&gt;Homepage URL：應用程式的首頁，以GitHub page的部落格而言，我是填GitHub page的網址&lt;/li&gt;
  &lt;li&gt;Application description：非必填&lt;/li&gt;
  &lt;li&gt;Authorization callback URL：同上面的&lt;strong&gt;Homepage URL&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在建立好GitHub Application以後，網頁上應該會出現client id和client secret，在後面的設定會使用到，值得一提的是，client secret只會顯示這麼一次，記得要好好的保存起來。&lt;/p&gt;

&lt;h3 id=&quot;修改_configyml&quot;&gt;修改_config.yml&lt;/h3&gt;

&lt;p&gt;在_config.yml裡面可以找到&lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme/blob/master/_config.yml#L118-L144&quot;&gt;有關comment設定的部分&lt;/a&gt;，需要修改的地方有兩塊，一個是需要把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;provider&lt;/code&gt;改成gitalk，另一個是在底下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gitalk&lt;/code&gt;的區塊要把列出來的資訊填好，而設定中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repository&lt;/code&gt;是將來儲存comment的repo，未來comment會儲存在該repo的issue裡面，必須要是public的，這個repo可以跟存放網頁的repo不同，一個修改過後的範例貼在底下，記得要將client id和client secret改掉。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;provider&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;gitalk&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# false (default), &quot;disqus&quot;, &quot;gitalk&quot;, &quot;valine&quot;, &quot;custom&quot;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# Disqus&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;disqus&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;shortname&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# the Disqus shortname for the site&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;## Gitalk&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# please refer to https://github.com/gitalk/gitalk for more info.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;gitalk&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;clientID    &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ENV_CLIENT_ID&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# GitHub Application Client ID&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;clientSecret&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ENV_CLIENT_SECRET&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# GitHub Application Client Secret&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;repository  &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wjohn1483.github.io&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# GitHub repo&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;owner       &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wjohn1483&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# GitHub repo owner&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# GitHub repo owner and collaborators, only these guys can initialize GitHub issues, IT IS A LIST.&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wjohn1483&quot;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;# - your GitHub Id&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# Valine&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# please refer to https://valine.js.org/en/ for more info.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;valine&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app_id      &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# LeanCloud App id&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app_key     &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# LeanCloud App key&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;placeholder &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Prompt information&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;visitor     &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# false (default)&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;meta        &lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# &quot;[nick, mail, link]&quot; (default) nickname, E-mail, Personal-site&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;值得一提的是，原本預設的proxy好像開始限定流量了，所以如果用預設的proxy會無法使用，範例中參考了&lt;a href=&quot;https://github.com/gitalk/gitalk/issues/429&quot;&gt;Gitalk issue&lt;/a&gt;中的解法，改掉預設的proxy。&lt;/p&gt;

&lt;h3 id=&quot;在文章當中加入key&quot;&gt;在文章當中加入key&lt;/h3&gt;

&lt;p&gt;為了要讓Gitalk知道那篇文章對應到那個issue，我們需要給每一篇文章獨一無二的id，並寫在文章的front matter裡面。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;article&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Document - Writing Posts&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;mathjax&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;your-article-id&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這個id在front matter裡面稱作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;，它的命名規則可以參考&lt;a href=&quot;https://tianqi.name/jekyll-TeXt-theme/docs/en/layouts#page-layout&quot;&gt;這裡&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在設定好以後，在本機執行編譯的指令，應該就能在每篇文章底下找到留言板了。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;JEKYLL_ENV&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;production bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;jekyll build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;直接使用在靜態網頁上&quot;&gt;直接使用在靜態網頁上&lt;/h2&gt;

&lt;p&gt;如果想要直接使用在單個html上面，不想跟jekyll主題綁在一起的話，可以參考&lt;a href=&quot;https://github.com/gitalk/gitalk#install&quot;&gt;Gitalk文件當中的方式&lt;/a&gt;，使用起來相當的簡單。&lt;/p&gt;

&lt;p&gt;只需要在你的html裡面&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;的地方，多引入Gitalk的javascript。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;並在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;裡面新增&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/code&gt;，把相關的變數設定好，client id和client secret的取得可以參考文章上面的&lt;a href=&quot;#建立github-application&quot;&gt;建立GitHub Application&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;gitalk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Gitalk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;clientID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;GitHub Application Client ID&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;clientSecret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;GitHub Application Client Secret&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;GitHub repo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// The repository of store comments,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;GitHub repo owner&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;GitHub repo owner and collaborators, only these guys can initialize github issues&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// Ensure uniqueness and length less than 50&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;distractionFreeMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Facebook-like distraction free mode&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;gitalk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;gitalk-container&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這邊有帶入&lt;a href=&quot;https://github.com/gitalk/gitalk/issues/429&quot;&gt;Gitalk issue&lt;/a&gt;裡面所提到的，其他人所提供的proxy，如果想用原本預設的proxy，直接將proxy的設定拿掉就行。&lt;/p&gt;

&lt;p&gt;最後在想要插入Gitalk的地方放個&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;gitalk-container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://xsaxy.gitee.io/blog/post/2019/12/10/%E4%B8%BB%E9%A2%98TeXt%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%B8%AD%E7%9A%84%E5%9D%91.html&quot;&gt;主题TeXt评论系统设置中的坑&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/gitalk/gitalk/issues/429&quot;&gt;在授权gitalk后出现403错误&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Lwl9rf95EqlTYLfconjflQ&quot;&gt;记录一次 Bug 排查过程并分享一些经验&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Tool" /><summary type="html">先前在設定檔裡面發現這個部落格主題可以開啟留言的功能，這邊簡單介紹一下其背後所使用的Gitalk以及如何設定它。</summary></entry><entry><title type="html">網路安全的基本知識</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/01/26/security-introduction/" rel="alternate" type="text/html" title="網路安全的基本知識" /><published>2021-01-26T00:00:00+00:00</published><updated>2021-01-26T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/01/26/security-introduction</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2021/01/26/security-introduction/">&lt;p&gt;有鑑於有時會接觸到一些網路安全的東西，這邊簡單紀錄一下碰到的一些東西。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;非對稱式密碼學&quot;&gt;非對稱式密碼學&lt;/h2&gt;

&lt;p&gt;在網路安全當中的很多基礎是建立在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86&quot;&gt;非對稱式密碼學（Asymmetric cryptography）&lt;/a&gt;上，而非對稱式密碼學又是奠基在&lt;a href=&quot;https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95&quot;&gt;RSA&lt;/a&gt;等非對稱加密演算法上。非對稱加密演算法可以產生出成對的公鑰和私鑰，用公鑰加密的文件只能用私鑰來解開，而用私鑰加密的文件也只能用公鑰來解開，在這樣的基礎上，我們就可以與其他人安全的傳遞資料，不怕被其他人偷看。&lt;/p&gt;

&lt;h3 id=&quot;安全傳遞訊息&quot;&gt;安全傳遞訊息&lt;/h3&gt;

&lt;p&gt;這邊簡單說明一下，如何使用非對稱加密演算法來安全的傳遞訊息。&lt;/p&gt;

&lt;p&gt;假如說今天愛麗絲想要傳遞訊息給鮑伯，但怕透過網路的話她所傳遞的訊息會被別人看到，這時，鮑伯可以用非對稱加密演算法先產生一對公鑰和私鑰，透過網路將公鑰傳遞給愛麗絲，而愛麗絲將她想要傳遞的訊息透過鮑伯的公鑰加密以後，透過網路再傳回給鮑伯，鮑伯再用私鑰來將訊息讀取出來。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Public_key_encryption_alice_to_bob.svg/langzh-500px-Public_key_encryption_alice_to_bob.svg.png&quot; alt=&quot;透過非對稱加密演算法安全傳遞訊息&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果有人一直在竊聽兩個人的對話，他雖然可以拿到鮑伯的公鑰以及愛麗絲透過公鑰加密過後的訊息，但因為沒有鮑伯的私鑰的關係，所以也看不到愛麗絲傳給鮑伯的訊息。&lt;/p&gt;

&lt;h3 id=&quot;數位簽章&quot;&gt;數位簽章&lt;/h3&gt;

&lt;p&gt;在上面的例子當中，雖說第三人沒有辦法看到愛麗絲傳遞給鮑伯的訊息，但他擁有鮑伯的公鑰，可以巧妙的偽裝成愛麗絲傳遞訊息給鮑伯。為了防止有人偽裝成愛麗絲，愛麗絲可以利用她自己的私鑰搭配雜湊函數來對訊息做簽名，而鮑伯拿到訊息以後，除了用自己的私鑰解開以外，還需要用愛麗絲的公鑰對簽名做驗證，如此便能防止有人假冒了。&lt;/p&gt;

&lt;h2 id=&quot;常見的網路安全名詞&quot;&gt;常見的網路安全名詞&lt;/h2&gt;

&lt;h3 id=&quot;ssltls&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A&quot;&gt;SSL/TLS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;SSL的全稱是Secure Sockets Layer，而TLS的全稱是Transport Layer Security，SSL是TLS的前身，而這兩個都是transport layer的安全協定。&lt;/p&gt;

&lt;h3 id=&quot;oauth&quot;&gt;OAuth&lt;/h3&gt;

&lt;p&gt;OAuth是一個開放的標準，來讓第三方的app有權利可以存取使用者在其他網站上面的資源，而不用將使用者的帳號密碼給第三方app，OAuth其實是個生活中常用到的標準，舉凡在Slack裡面連結Google Drive的帳戶，或是在電子信箱裡面連結其他電子信箱等，底層使用的可能都是OAuth的標準。&lt;/p&gt;

&lt;p&gt;OAuth具體的操作方式可以參考&lt;a href=&quot;https://petertc.medium.com/oauth-2-0-196a5550b668&quot;&gt;這篇文章&lt;/a&gt;，簡單來說，假設我今天想要透過服務A存取我放在服務B的資料，我得要先去服務B那邊申請說我想要讓第三方服務存取資料，並從服務B拿到Authorization Code，接著我把這Authorization Code給服務A，服務A會拿著這個Authorization Code去服務B那邊換取Access Token，之後服務A就可以使用這Access Token存取我在服務B上面的資料了。&lt;/p&gt;

&lt;h3 id=&quot;yubikey&quot;&gt;Yubikey&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/YubiKey&quot;&gt;Yubikey&lt;/a&gt;是由Yubico這家公司出產的身分認證裝置，常用在二階段認證上，在使用的時候是插在電腦上，並在需要時觸碰它。&lt;/p&gt;

&lt;h3 id=&quot;x509&quot;&gt;X.509&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/X.509&quot;&gt;X.509&lt;/a&gt;是一個格式標準，常用在包括SSL/TLS在內的網路協定裡。它的概念是說，當我想要跟某台素未蒙面的主機聯繫的時候，我不清楚那台主機能不能夠被信任、是不是別人假裝的，這時就會需要一個公正的CA（Certificate Authority）來幫忙，如果對方的主機可以提供我所信任的CA的憑證（Certificate），那麼我就相信對方是可以被信任的而傳送資料過去。&lt;/p&gt;

&lt;p&gt;而CA的架構是金字塔型，主要頒發憑證的是中間的認證中心，他們上面還有更高的認證中心，詳細的資訊可以參考&lt;a href=&quot;https://www.imacat.idv.tw/tech/sslcerts.html.zh-tw#sslx509&quot;&gt;這篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;athenz&quot;&gt;Athenz&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yahoo/athenz&quot;&gt;Athenz&lt;/a&gt;是由Yahoo開源、基於X.509權限管理系統，使用集中式的授權，並以role為基礎，透過指定某個role對某個資源允許或拒絕某些動作來達成授權行為，任何服務想要知道我有沒有權限存取資料的時候，都要去跟權限管理系統詢問，所以可能會有單點故障以及流量的問題，具體的授權流程可以參考&lt;a href=&quot;https://github.com/yahoo/athenz/blob/master/docs/auth_flow.md&quot;&gt;官方的文件&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;mtls&quot;&gt;mTLS&lt;/h3&gt;

&lt;p&gt;mTLS的全稱應該是Mutual TLS，指的是雙方都去驗證對方的身分。在一般的情境下，可能只有使用者需要去驗證服務是不是可以被信任的，但有些時候如果要交換一些比較機密的資料時，就會需要兩邊都做驗證，也就是雙方要各自準備好各自的key、certificate和CA的certificate。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Server需要準備：server.key、server.crt、ca.crt&lt;/li&gt;
  &lt;li&gt;Client需要準備：client.key、client.crt、ca.crt&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;okta&quot;&gt;Okta&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Okta_(identity_management)&quot;&gt;Okta&lt;/a&gt;是一家公司，提供其他企業SSO（Single Sign On）的服務，讓企業的員工可以只登入一次就可以存取各式各樣的服務，Okta還提供其他多重要素驗證等等的服務。&lt;/p&gt;

&lt;h3 id=&quot;ckms&quot;&gt;CKMS&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cryptomathic.com/products/key-management/crypto-key-management-system&quot;&gt;CKMS&lt;/a&gt;的全稱好像是Crypto Key Management System，是一個幫忙更新、部署key的系統。&lt;/p&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@RiverChan/%E5%9F%BA%E7%A4%8E%E5%AF%86%E7%A2%BC%E5%AD%B8-%E5%B0%8D%E7%A8%B1%E5%BC%8F%E8%88%87%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86%E6%8A%80%E8%A1%93-de25fd5fa537&quot;&gt;基礎密碼學(對稱式與非對稱式加密技術)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://petertc.medium.com/oauth-2-0-196a5550b668&quot;&gt;妳知道第三方應用是怎麼存取妳的雲端資料嗎？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jimwayne.blogspot.com/2019/04/athenz.html&quot;&gt;黑毛到白毛的攻城獅之路: Athenz 的授權流程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.imacat.idv.tw/tech/sslcerts.html.zh-tw#sslx509&quot;&gt;如何製作SSL X.509憑證？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/ustccw/article/details/76691248&quot;&gt;SSL/TLS 双向认证(一) – SSL/TLS 工作原理_ustccw-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><category term="Network-Security" /><summary type="html">有鑑於有時會接觸到一些網路安全的東西，這邊簡單紀錄一下碰到的一些東西。</summary></entry><entry><title type="html">利用Circle CI來更新GitHub Pages</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/11/21/circle-ci/" rel="alternate" type="text/html" title="利用Circle CI來更新GitHub Pages" /><published>2020-11-21T00:00:00+00:00</published><updated>2020-11-21T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/11/21/circle-ci</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/11/21/circle-ci/">&lt;p&gt;有鑒於&lt;a href=&quot;https://blog.travis-ci.com/2020-11-02-travis-ci-new-billing&quot;&gt;Travis CI要開始收費了&lt;/a&gt;，所以我將部落格的CI轉移到&lt;a href=&quot;https://circleci.com&quot;&gt;Circle CI&lt;/a&gt;上，在這篇文章記錄一下轉移的過程。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;為什麼要使用circle-ci&quot;&gt;為什麼要使用Circle CI？&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;https://wjohn1483.github.io/2020/02/28/create-website-by-Jekyll/&quot;&gt;之前的文章&lt;/a&gt;裡面，使用了Travis CI來幫助我們使用原先Github不支援的Jekyll套件，透過Travis CI的虛擬機幫我們安裝套件以後編譯網站，最後push到master branch上。&lt;/p&gt;

&lt;p&gt;只不過因為種種的因素，現在Travis CI要開始收費了，一般沒有付費的使用者在使用完贈與的credits以後，就得要掏錢來請他們幫忙build，為了繼續當免費仔，我查詢了一下與Travis CI類似的服務，找到了Circle CI，而目前&lt;a href=&quot;https://circleci.com/pricing/&quot;&gt;Circle CI的收費方式&lt;/a&gt;是每週給你2,500個credits，大約是每週給你250分鐘的時間使用2 CPUs / 4GB RAM的機器，用來更新網站應該是綽綽有餘了。&lt;/p&gt;

&lt;h2 id=&quot;circle-ci的使用方式&quot;&gt;Circle CI的使用方式&lt;/h2&gt;

&lt;h3 id=&quot;建立設定檔&quot;&gt;建立設定檔&lt;/h3&gt;

&lt;p&gt;Circle CI和Travis CI使用的方式差不多，我們會需要在目錄底下創建&lt;strong&gt;.circleci/&lt;/strong&gt;這個資料夾，Circle CI會去讀取資料夾內的設定檔&lt;strong&gt;.circleci/config.yml&lt;/strong&gt;，來決定要怎麼build你的repository，底下是一個簡單的範例。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;orbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ruby&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;circleci/ruby@0.1.2&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;build_and_push&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;docker&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;circleci/ruby:2.6.3-stretch-node&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ruby/default&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;checkout&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ruby/bundle-install&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Build website&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle exec jekyll build&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Install rsync&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;sudo apt install -y rsync&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;deploy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Push to master branch&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;if [ -z ${CIRCLE_PULL_REQUEST} ]; then&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;bash ./.circleci/push.sh&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;workflows&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;update_website&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;build_and_push&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;filters&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;branches&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;only&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;source&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;設定檔裡面我們需要自己修改的部分是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jobs&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;workflows&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jobs&lt;/code&gt;裡面會定義各式各樣的工作，可以想成是function一樣的地位，會執行設定好的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;steps&lt;/code&gt;，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkout&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ruby/bundle-install&lt;/code&gt;是原本範本裡面就有的兩個步驟，做的事情分別是把程式碼抓下來、安裝ruby的套件，如果想要在docker裡面安裝其他套件的話，可以透過&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt install&lt;/code&gt;來安裝。&lt;/p&gt;

&lt;p&gt;值得一提的是，在最後一步的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deploy&lt;/code&gt;，如果有給Circle CI Github的token的話，這步會直接幫你設定好，不需要自己在script裡面把token用環境變數帶進來。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;workflows&lt;/code&gt;可以想成是main function，會定義要執行哪些jobs，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filters&lt;/code&gt;是決定要不要執行這個job的條件，像上面例子的設定是只有&lt;em&gt;source branch&lt;/em&gt;的commit才會執行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build_and_push&lt;/code&gt;這個job。&lt;/p&gt;

&lt;h3 id=&quot;連結github與circle-ci&quot;&gt;連結GitHub與Circle CI&lt;/h3&gt;

&lt;p&gt;在建立好設定檔以後，接下來就是連結GitHub和Circle CI，要做的事情大概如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;創建帳號並選擇你想要連結的repository&lt;/p&gt;

    &lt;p&gt;直接上去&lt;a href=&quot;https://circleci.com&quot;&gt;Circle CI&lt;/a&gt;的網站透過GitHub帳號登入，授權以後就可以看到自己的repository了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;給予Circle CI讀取和push的權限&lt;/p&gt;

    &lt;p&gt;到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Project Settings&lt;/code&gt;裡面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH Keys&lt;/code&gt;，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User Key&lt;/code&gt;的地方有個按鈕可以幫你跟GitHub說你想要讓Circle CI有權限push到這邊，授權完成以後就可以在畫面上看到Circle CI獲得的key了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(Optional) 設定環境變數&lt;/p&gt;

    &lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Project Settings&lt;/code&gt;裡面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Environment Variables&lt;/code&gt;可以依據個人的需要設定環境變數&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在做完上述的事情以後，接下來push的commit就會被Circle CI發現並自動幫你build了。&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jtway.co/deploying-jekyll-to-github-pages-with-circleci-2-0-3eb69324bc6e&quot;&gt;Deploying Jekyll to GitHub Pages with CircleCI 2.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Your Name</name></author><category term="Tool" /><summary type="html">有鑒於Travis CI要開始收費了，所以我將部落格的CI轉移到Circle CI上，在這篇文章記錄一下轉移的過程。</summary></entry></feed>