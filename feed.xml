<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/" rel="alternate" type="text/html" /><updated>2020-03-02T15:09:41+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/</id><title type="html">wjohn1483.github.io</title><subtitle></subtitle><author><name>Your Name</name></author><entry><title type="html">Self-Supervised Generalisation with Meta Auxiliary Learning</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/03/01/self-supervised-generalisation-with-meta-auxiliary-learning/" rel="alternate" type="text/html" title="Self-Supervised Generalisation with Meta Auxiliary Learning" /><published>2020-03-01T00:00:00+00:00</published><updated>2020-03-01T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/03/01/self-supervised-generalisation-with-meta-auxiliary-learning</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/03/01/self-supervised-generalisation-with-meta-auxiliary-learning/">&lt;p&gt;通常在訓練的時候，如果能有一些輔助的任務(task)，通常會對主要的任務在效能上有所提升，然而這些輔助任務的答案通常會需要人類來標注，並不能隨意的想加輔助任務就加輔助任務，而這篇文章要介紹的NeurIPS 2019的&lt;a href=&quot;https://papers.nips.cc/paper/8445-self-supervised-generalisation-with-meta-auxiliary-learning.pdf&quot;&gt;Self-Supervised Generalisation with Meta Auxiliary Learning&lt;/a&gt;，將輔助任務的答案都用機器來產生，免去了準備輔助任務答案的麻煩。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;簡介&quot;&gt;簡介&lt;/h2&gt;
&lt;p&gt;在先前的研究當中，大多表示如果可以讓model能夠同時有多個任務可以學習，並且共用部分參數的話，對於整體學習的成果會有所提升。&lt;/p&gt;

&lt;p&gt;舉個例子來說，如果今天想要做一個影像辨識的模型，輸入是一張動物的圖片，輸出是該動物的種類，像是貓、狗、鳥等等，我們可以直接疊一些CNN，把圖片丟進去，輸出就直接是動物的種類，gradient descent硬做一波，然而如果我們有更多的資訊，像是知道貓是屬於貓科、狗是屬於犬科，我們可以在model的中間或是在最後額外拉出一條flow來去判別這個動物的科別，通常後者在判斷動物種類的效果應該會比較好，因為在前面CNN的部分更可以知道哪些資訊是需要被保留的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;framework.png&quot; alt=&quot;auxiliary_framework&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不過這樣子的方式其實是很需要人類幫助的，我們需要知道判斷動物種類可以參考科別，而且我們也需要對每一張圖片除了標注種類，還要額外標注科別，答案的獲取相當的昂貴，為此，這篇paper希望能夠讓機器來取代人類，自動產生出一些有意義的輔助答案來幫助主要的任務能學得更好，而上方的圖是這篇paper的示意圖。&lt;/p&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;
&lt;h3 id=&quot;model架構圖&quot;&gt;Model架構圖&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;model_architecture.png&quot; alt=&quot;model architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這篇paper將他們所創造出來的model稱之為Meta AuXiliary Learning (MAXL)，由兩個model所組成，分別是在圖片上半部的&lt;em&gt;Multi-task Network&lt;/em&gt;和下半部的&lt;em&gt;Label-Generation Network&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;multi-task-network&quot;&gt;Multi-task Network&lt;/h3&gt;

&lt;p&gt;Multi-task Network就是我們主要的neural network，其參數為&lt;script type=&quot;math/tex&quot;&gt;\theta_1&lt;/script&gt;，輸入&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;，輸出primary task和auxiliary task的答案&lt;script type=&quot;math/tex&quot;&gt;f_{\theta_1}^{pri}(x)&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;f_{\theta_1}^{aux}(x)&lt;/script&gt;，其中auxiliary task的答案&lt;script type=&quot;math/tex&quot;&gt;y^{aux}&lt;/script&gt;是由底下的Label-Generation Network所預測出來的。&lt;/p&gt;

&lt;p&gt;而這個network的目標是希望能夠分對primary task以及auxiliary task，所以它的objective function為&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\arg\limits_{\theta_1}\min\left( \mathcal{L}\left( f_{\theta_1}^{pri}(x_{(i)}), y_{(i)}^{pri} \right) + \mathcal{L} \left( f_{\theta_1}^{aux}(x_{(i)}), y_{(i)}^{aux} \right) \right)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Focal\ loss : \mathcal{L}(\hat y, y)=-y(1-\hat y)^\gamma\log(\hat y)&lt;/script&gt;

&lt;p&gt;其中所使用的loss function為focal loss，在paper裡說可以幫助model更專注在錯誤的predict上。&lt;/p&gt;

&lt;h3 id=&quot;label-generation-network&quot;&gt;Label-Generation Network&lt;/h3&gt;

&lt;p&gt;Label-Generation Network的目的是希望能夠產生出讓Multi-task Network可以學得更好的label，所以它的objective function被設定為&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\arg\limits_{\theta_2}\min\mathcal{L}\left( f_{\theta_1^+}^{pri}(x_{(i)}),y_{(i)}^{pri} \right)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\theta_1^+=\theta_1-\alpha\bigtriangledown_{\theta_1}\left( \mathcal{L} \left( f_{\theta_1}^{pri}(x_{(i)}), y_{(i)}^{pri} \right) + \mathcal{L} \left( f_{\theta_1}^{aux}(x_{(i)}), y_{(i)}^{aux} \right) \right)&lt;/script&gt;

&lt;p&gt;此objective function的含義是，在Multi-task Network經過一次更新以後，希望它在primary task上的loss可以最小，這個概念有點類似&lt;a href=&quot;https://arxiv.org/pdf/1703.03400.pdf&quot;&gt;MAML&lt;/a&gt;中，希望找到一個初始參數，讓model在更新過後可以在各個task上的綜合表現最佳。&lt;/p&gt;

&lt;p&gt;然而經過他們的實驗發現，用上方的objective function來訓練的話，Label-Generation Network常常會輸出同樣的label，所以在實際上更新的時候會再多加一個regularization loss如下&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\theta_2=\theta_2-\beta\bigtriangledown_{\theta_2}\left( \mathcal{L}\left( f_{\theta_1^+}^{pri}(x_{(i)}), y_{(i)}^{pri} \right) + \lambda \mathcal{H}(y_{(i)}^{aux})\right)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{H}(\hat y_{(i)})=\sum\limits_{k=1}\limits^{K}\hat y_{(i)}^k\log \hat y_{(i)}^k,\ \ \hat y_{(i)}^k=\frac{1}{N}\sum\limits_{n=1}\limits^{N}\hat y_{(i)}^k[n]&lt;/script&gt;

&lt;p&gt;此regularization loss的意思是，希望在每個batch所產生出來的每個label，它的entropy可以越大越好。&lt;/p&gt;

&lt;p&gt;在一開始讀到這邊的時候，我有一個沒有想通的地方是，從&lt;script type=&quot;math/tex&quot;&gt;\theta_2&lt;/script&gt;更新的式子(5)裡面來看，只有後面regularization的那項跟&lt;script type=&quot;math/tex&quot;&gt;\theta_2&lt;/script&gt;有關，微分中的第一項好像看不出來跟&lt;script type=&quot;math/tex&quot;&gt;\theta_2&lt;/script&gt;有關係，後來探究了一下，發現應該要把第一項展開才能看得出來它跟&lt;script type=&quot;math/tex&quot;&gt;\theta_2&lt;/script&gt;的關係，在式(4)中微分裡面的第二項裡的&lt;script type=&quot;math/tex&quot;&gt;y_{(i)}^{aux}&lt;/script&gt;是由Label-Generation Network產生的，所以式(4)更精確的寫法是&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\theta_1^+=\theta_1-\alpha\bigtriangledown_{\theta_1}\left( \mathcal{L} \left( f_{\theta_1}^{pri}(x_{(i)}), y_{(i)}^{pri} \right) + \mathcal{L} \left( f_{\theta_1}^{aux}(x_{(i)}), f_{\theta_2}(x_{(i)}) \right) \right)&lt;/script&gt;

&lt;p&gt;式(5)就可以改寫成&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\theta_2=\theta_2-\beta\bigtriangledown_{\theta_2}\left( \mathcal{L}\left( f_{\theta_1-\alpha\bigtriangledown_{\theta_1}\left( \mathcal{L} \left( f_{\theta_1}^{pri}(x_{(i)}), y_{(i)}^{pri} \right) + \mathcal{L} \left( f_{\theta_1}^{aux}(x_{(i)}), f_{\theta_2}(x_{(i)}) \right) \right)}^{pri}(x_{(i)}), y_{(i)}^{pri} \right) + \lambda \mathcal{H}(y_{(i)}^{aux})\right)&lt;/script&gt;

&lt;p&gt;這時就可以看出來第一項其實也是跟&lt;script type=&quot;math/tex&quot;&gt;\theta_2&lt;/script&gt;有關，只是是二次微分，一個Hessian matrix，好在大多機器學習的工具像是tensorflow和pytorch都有支援Hessian matrix的計算，所以在程式碼裡面只需要寫成式(5)那樣就可以算微分了，可以看&lt;a href=&quot;https://github.com/lorenmt/maxl/blob/master/model_vgg_maxl.py#L402&quot;&gt;paper的原始碼&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;mask-softmax&quot;&gt;Mask Softmax&lt;/h4&gt;

&lt;p&gt;在paper裡面有另外提到說，他們覺得在訓練每個不同primary task的類別時，應該給予不一樣的auxiliary label，像是在訓練&lt;script type=&quot;math/tex&quot;&gt;y^{pri}=0&lt;/script&gt;這個類別的時候，所給予的auxiliary label應該就只專門拿來用在&lt;script type=&quot;math/tex&quot;&gt;y^{pri}=0&lt;/script&gt;的情況上，不應該在不同的&lt;script type=&quot;math/tex&quot;&gt;y^{pri}&lt;/script&gt;都給同樣的auxiliary label，所以在Label-Generation Network有一個&lt;script type=&quot;math/tex&quot;&gt;\psi&lt;/script&gt;，代表的是對於每個不同的&lt;script type=&quot;math/tex&quot;&gt;y^{pri}&lt;/script&gt;，要給予多少個auxiliary class，如果&lt;script type=&quot;math/tex&quot;&gt;\psi=[2, 2]&lt;/script&gt;的話，就代表給&lt;script type=&quot;math/tex&quot;&gt;y^{pri}=0&lt;/script&gt;兩個auxiliary class，也給&lt;script type=&quot;math/tex&quot;&gt;y^{pri}=1&lt;/script&gt;兩個auxiliary class。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;mask_softmax.png&quot; alt=&quot;mask softmax&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;maxl-algorithm&quot;&gt;MAXL Algorithm&lt;/h3&gt;

&lt;p&gt;下圖為這篇paper附上的algorithm。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;maxl_algorithm.png&quot; alt=&quot;MAXL Algorithm&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;實驗&quot;&gt;實驗&lt;/h2&gt;

&lt;h2 id=&quot;結論&quot;&gt;結論&lt;/h2&gt;</content><author><name>Your Name</name></author><category term="Paper" /><category term="Meta-Learning" /><category term="Auxiliary-Learning" /><summary type="html">通常在訓練的時候，如果能有一些輔助的任務(task)，通常會對主要的任務在效能上有所提升，然而這些輔助任務的答案通常會需要人類來標注，並不能隨意的想加輔助任務就加輔助任務，而這篇文章要介紹的NeurIPS 2019的Self-Supervised Generalisation with Meta Auxiliary Learning，將輔助任務的答案都用機器來產生，免去了準備輔助任務答案的麻煩。</summary></entry><entry><title type="html">如何使用Jekyll建立網站在Github Page上</title><link href="https://wjohn1483.github.io/#%20the%20base%20hostname%20&%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/02/28/create-website-by-Jekyll/" rel="alternate" type="text/html" title="如何使用Jekyll建立網站在Github Page上" /><published>2020-02-28T00:00:00+00:00</published><updated>2020-02-28T00:00:00+00:00</updated><id>https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/02/28/create-website-by-Jekyll</id><content type="html" xml:base="https://wjohn1483.github.io/#%20the%20base%20hostname%20&amp;%20protocol%20for%20your%20site%20e.g.%20https://www.someone.com/2020/02/28/create-website-by-Jekyll/">&lt;p&gt;這篇文章將會簡單介紹一下Jekyll，以及我如何使用Jekyll將網站建置在GitHub Page上的經歷。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;jekyll是什麼&quot;&gt;Jekyll是什麼？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;是一個基於Ruby的靜態網頁產生器，常用在個人、project或是公司、組織的網頁上，由GitHub的co-founder &lt;a href=&quot;https://en.wikipedia.org/wiki/Tom_Preston-Werner&quot;&gt;Tom Preston-Wemer&lt;/a&gt;製作的。&lt;/p&gt;

&lt;p&gt;只要給Jekyll一些Liquid模板以及用Markdown寫的文章內容，它就可以幫你生成出一整個靜態網站。
&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt;是一個模板引擎，可以在html裡面安插一些程式語言，讓html可以根據你的需求被產生出來，可以參考&lt;a href=&quot;https://github.com/Shopify/liquid#what-does-it-look-like&quot;&gt;Liquid GitHub當中的例子&lt;/a&gt;，會比較理解它想要實現的事情。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;products&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    
    {% for product in products %}
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;{{ product.name  }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
            Only {{ product.price | price  }}

            {{ product.description | prettyprint | paragraph  }}
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
    {% endfor %}
    
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至於&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/Markdown&quot;&gt;Markdown&lt;/a&gt;，是一個輕量級標記式語言，相信有使用過GitHub的人應該對它並不陌生。&lt;/p&gt;

&lt;p&gt;或許是因為Jekyll是由GitHub co-founder所製作的，所以目前GitHub Page支援Jekyll，使你可以在你的repo當中放入Jekyll的原始碼，GitHub就會自動幫你編譯並部署成網站。
底下將會從零開始，紀錄我如何建立一個部落格網站。&lt;/p&gt;

&lt;h2 id=&quot;準備環境&quot;&gt;準備環境&lt;/h2&gt;
&lt;h3 id=&quot;直接套用現成repo&quot;&gt;直接套用現成Repo&lt;/h3&gt;
&lt;p&gt;如果說不想要這麼麻煩的準備環境，想要直接開始寫作的話，可以去網路上找別人已經弄好的GitHub Repo，像是&lt;a href=&quot;https://github.com/github/personal-website&quot;&gt;personal-website&lt;/a&gt;，Fork到自己的帳號底下，改一下repo的名字，變成&lt;strong&gt;[username].github.io&lt;/strong&gt;，就可以開始在&lt;strong&gt;_post&lt;/strong&gt;這個資料夾底下創立Markdown檔案，開始自由的創作，GitHub理應會將你新創立的文章自動變成網頁部署上去。&lt;/p&gt;

&lt;p&gt;倘若你想要客製化網站的話，可能就必須自己準備一個環境，得要繼續往下閱讀了。&lt;/p&gt;

&lt;h3 id=&quot;建立github-page-repo&quot;&gt;建立GitHub Page Repo&lt;/h3&gt;
&lt;p&gt;網路上有很多教學來教大家如何建立自己的GitHub Page，可以參考&lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub官方教學&lt;/a&gt;。
其實主要需要做的事情就是建立一個新的repository，命名為&lt;strong&gt;[username].github.io&lt;/strong&gt;，並將之設為public repo。
之後只要將html檔案上傳上去，GitHub就會自動將檔案部署到&lt;strong&gt;https://[username].github.io&lt;/strong&gt;這個網站上，相當的方便而且還免費！&lt;/p&gt;

&lt;h3 id=&quot;安裝rubyjekyll&quot;&gt;安裝Ruby、Jekyll&lt;/h3&gt;
&lt;p&gt;前面有提到Jekyll是基於Ruby所建立的，所以必須要在自己的電腦上先安裝Ruby，安裝Ruby的方法可以參考&lt;a href=&quot;https://jekyllrb.com/docs/installation/&quot;&gt;Jekyll官方教學&lt;/a&gt;，根據不同的作業系統會需要不一樣的步驟，但倘若你所使用的是macOS Catalina以上的作業系統，其內建就有Ruby了，可以直接安裝Jekyll。&lt;/p&gt;

&lt;p&gt;在安裝好Ruby以後，直接下底下的指令應該就能安裝好Jekyll。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;bundler jekyll &lt;span class=&quot;nt&quot;&gt;--user-install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用樣板建立第一個網站&quot;&gt;使用樣板建立第一個網站&lt;/h2&gt;
&lt;p&gt;在準備好環境以後，應該就迫不及待的想要產生一個好棒棒的網站，最快的方式應當是去複製別人的樣板，這邊我所使用的樣板是&lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme&quot;&gt;jekyll-TeXt-theme&lt;/a&gt;，你也可以去找尋自己心中所屬的那個樣板，像是蠻像Medium的樣板&lt;a href=&quot;https://github.com/poole/poole&quot;&gt;Poole&lt;/a&gt;等等。&lt;/p&gt;

&lt;p&gt;想好樣板選哪一個以後，接著便是在你的GitHub Page Repo上套用它，套用的流程可以參考底下。&lt;/p&gt;

&lt;h3 id=&quot;clone你的github-page-repo到電腦上&quot;&gt;Clone你的GitHub Page Repo到電腦上&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/[username]/[username].github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;在repo根目錄創建gemfile和_confyaml&quot;&gt;在repo根目錄創建Gemfile和_conf.yaml&lt;/h3&gt;

&lt;p&gt;通常樣板都是用gem的形式來讓大家使用，為此我們需要建立&lt;strong&gt;Gemfile&lt;/strong&gt;和&lt;strong&gt;_conf.yaml&lt;/strong&gt;這兩個檔案，來讓Ruby知道我們這個repo需要哪些相關的gem。&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Put the followings into your Gemfile&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://rubygems.org&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jekyll&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jekyll-text-theme&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Put the following into your _conf.yaml&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;theme&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jekyll-text-theme&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;安裝套件&quot;&gt;安裝套件&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--path&lt;/span&gt; vendor/bundle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的指令會把需要的套件都安裝在&lt;strong&gt;vendor/bundle&lt;/strong&gt;這個資料夾內。&lt;/p&gt;

&lt;h3 id=&quot;把樣板所定義的css設定檔放到repo根目錄&quot;&gt;把樣板所定義的CSS、設定檔放到repo根目錄&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; vendor/bundle/ruby/2.6.0/gems/jekyll-text-theme-2.2.6/_&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; ./
&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; vendor/bundle/ruby/2.6.0/gems/jekyll-text-theme-2.2.6/assets ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;把網頁模版複製進repo根目錄&quot;&gt;把網頁模版複製進repo根目錄&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme&quot;&gt;jekyll-TeXt-theme&lt;/a&gt;所需要的網頁模版可以參考其&lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme/tree/master/test&quot;&gt;repo底下的test資料夾&lt;/a&gt;，我印象中那時是複製了底下這些檔案。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;404.html
_config.yml
archive.html
index.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;確認樣板是否順利套用&quot;&gt;確認樣板是否順利套用&lt;/h3&gt;
&lt;p&gt;利用底下的指令讓Jekyll產生靜態網站。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;jekyll serve &lt;span class=&quot;nt&quot;&gt;--trace&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;產生出來的html檔案們會在&lt;strong&gt;_site/&lt;/strong&gt;這個資料夾內，你也可以到&lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt;上觀看自己的網頁。&lt;/p&gt;

&lt;p&gt;如果成功看到網頁跑出來，就代表套用算是成功了，接下來就可以開始進行客製化，像是去&lt;strong&gt;_conf.yaml&lt;/strong&gt;做一些設定、調整&lt;strong&gt;_include&lt;/strong&gt;裡面的html模板等等，把網頁刻成你的樣子。&lt;/p&gt;

&lt;h2 id=&quot;部署到github-page上&quot;&gt;部署到GitHub Page上&lt;/h2&gt;
&lt;p&gt;在把網頁變成了你的樣子以後，接著就會想讓世人看看，想把網頁丟到GitHub Page上。
因為Github會自動幫你編譯Jekyll，所以並不需要將整個&lt;strong&gt;_site/&lt;/strong&gt;資料夾上傳，記得把不需要的東西放入&lt;strong&gt;.gitignore&lt;/strong&gt;當中。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.bundle/
.jekyll-cache/
Gemfile.lock
vendor/
.sass-cache/
.site/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;值得一提的是，因為GitHub在編譯的時候會在safe mode底下執行，所支援的套件有限，可以參考&lt;a href=&quot;https://pages.github.com/versions/&quot;&gt;GitHub Dependency Versions&lt;/a&gt;，如果有用到超出支援的套件的話會編譯不過。&lt;/p&gt;

&lt;p&gt;在push到GitHub以後，可以去repo settings中GitHub Page相關的段落看有沒有錯誤訊息，如果成功部署上去可以看到相關的訊息，如果過程中發生了錯誤，在&lt;a href=&quot;https://help.github.com/en/enterprise/2.14/user/articles/troubleshooting-github-pages-builds&quot;&gt;troubleshooting github page builds&lt;/a&gt;能夠看到更多有關錯誤訊息的資訊。&lt;/p&gt;

&lt;h3 id=&quot;如果我想用超出支援的套件怎麼辦&quot;&gt;如果我想用超出支援的套件怎麼辦？&lt;/h3&gt;
&lt;p&gt;其實Github Page也支援一般的靜態網頁存放方式，所以可以先在本機把網頁編譯好以後，將&lt;strong&gt;_site/&lt;/strong&gt;裡面所有的東西都push到master branch，並放一個&lt;strong&gt;.nojekyll&lt;/strong&gt;的文件在裡面，如此一來就能使用超出支援的套件了，只是是在本機端。&lt;/p&gt;

&lt;p&gt;可以參考&lt;a href=&quot;https://www.drewsilcock.co.uk/custom-jekyll-plugins&quot;&gt;Custom Jekyll plugins with GitHub Pages&lt;/a&gt;，把Jekyll相關的原始碼放進source branch，把產生出來的靜態網頁放進master branch，讓整個東西都還是位在同一個repo底下。&lt;/p&gt;

&lt;p&gt;具體來說那篇文章想做的事情類似底下的指令，但上面文章會把master branch的根目錄設在source branch中的&lt;strong&gt;_site/&lt;/strong&gt;裡面，讓使用者可以編譯完，就進去&lt;strong&gt;_site/&lt;/strong&gt;資料夾內將新產生的html推上master branch。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Push source to origin and copy site to temp folder&lt;/span&gt;
git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;source
&lt;/span&gt;git push origin &lt;span class=&quot;nb&quot;&gt;source
cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; _site/ /tmp/

&lt;span class=&quot;c&quot;&gt;# Remove all files in master&lt;/span&gt;
git checkout master
&lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rf&lt;/span&gt; ./&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Copy site to master&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; /tmp/_site/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; ./
&lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; .nojekyll

&lt;span class=&quot;c&quot;&gt;# Push master to origin&lt;/span&gt;
git add &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Upload site&quot;&lt;/span&gt;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;如果我想要線上編輯怎麼辦&quot;&gt;如果我想要線上編輯怎麼辦？&lt;/h3&gt;
&lt;p&gt;上面所介紹的方式雖然可以使用沒有支援的套件，但是仍需要在本機編譯，所以每次發佈一篇新的文章時，會需要將新文章的原始碼push到source branch，編譯完成後再進入其中的&lt;strong&gt;_site/&lt;/strong&gt;資料夾把東西push到master branch，這樣才算成功把網頁更新。&lt;/p&gt;

&lt;p&gt;倘若我今天心血來潮在GitHub網頁版上面直接寫起了文章，想要發佈出去的話，還得要打開終端機pull source branch的資料、編譯一下、把東西推到master branch，相當的不方便，所以在此提供一個解法讓你可以在網頁版GitHub的source branch寫完文章以後，commit完可以直接發佈至master branch，於此同時還可以保有使用GitHub Page沒有支援的套件的好處。&lt;/p&gt;

&lt;p&gt;簡述一下解法便是利用Travis CI的虛擬機，幫我們把網頁編譯好，再請它幫我們把編譯好的網站push回master branch。&lt;/p&gt;

&lt;h4 id=&quot;travis-ci-簡介&quot;&gt;Travis CI 簡介&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt;是一個用來作持續整合(CI)的平台，只要在Travis CI連結GitHub，並在repo根目錄當中製作一個&lt;strong&gt;.travis.yml&lt;/strong&gt;檔案，告訴它想要在CI的時候執行什麼樣的指令，它就會建立一個虛擬機並執行你設定的指令。&lt;/p&gt;

&lt;h4 id=&quot;連結travis-ci和github&quot;&gt;連結Travis CI和GitHub&lt;/h4&gt;
&lt;p&gt;到&lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt;的網站中，點選&lt;em&gt;Sign in with GitHub&lt;/em&gt;，並給予它觀看repo的權限，它就可以知道你有哪些repo，接著選擇&lt;strong&gt;[username].github.io&lt;/strong&gt;的repo並勾選右邊的啟動按鈕，如此一來Travis CI就會開始監測你的repo有沒有新的commit。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;activate_ci.png&quot; alt=&quot;Activate Travis CI&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;給予travis-ci-push的權限&quot;&gt;給予Travis CI push的權限&lt;/h4&gt;
&lt;p&gt;為了要讓Travis CI可以幫忙把網頁push到master branch當中，我們需要給予它GitHub token，讓它能夠有權利push，可以到&lt;a href=&quot;https://github.com/settings/tokens&quot;&gt;GitHub settings&lt;/a&gt;創建一個token給Travis CI使用，並勾選給予的權限。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;github_permission.png&quot; alt=&quot;GitHub token permission&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拿到token以後，可以把token儲存在Travis CI的環境變數當中，若把token放repo裡面怕會被別人看到，儲存成變數的方法可以參照&lt;a href=&quot;https://docs.travis-ci.com/user/environment-variables#defining-variables-in-repository-settings&quot;&gt;Travis官方文件&lt;/a&gt;，點選repo的設定以後，就可以找到相關的區塊了，我自己是設定成底下的樣子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;travis_ci_variable.png&quot; alt=&quot;Travis CI Environment Variables&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;設定travis-ci&quot;&gt;設定Travis CI&lt;/h4&gt;
&lt;p&gt;至此我們讓Travis CI實時監控我們的commit，也讓它有權力可以push到master branch，接著就是告訴它該怎麼樣編譯我們的網站以及要把哪些東西push到master branch。&lt;/p&gt;

&lt;p&gt;我是參照&lt;a href=&quot;https://gist.github.com/willprice/e07efd73fb7f13f917ea#file-travis-yml&quot;&gt;別人的gist&lt;/a&gt;稍作修改以後來設定的，可以參考我的&lt;a href=&quot;https://github.com/wjohn1483/wjohn1483.github.io/blob/source/.travis.yml&quot;&gt;.travis.yml&lt;/a&gt;和&lt;a href=&quot;https://github.com/wjohn1483/wjohn1483.github.io/blob/source/.travis/push.sh&quot;&gt;.travis/push.sh&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# .travis.yml&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ruby&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rvm&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle exec jekyll build&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;after_success&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$TRAVIS_PULL_REQUEST&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;bash&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-x&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.travis/push.sh;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;fi'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# .travis/push.sh&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

setup_git_folder&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    git init
    git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.email &lt;span class=&quot;s2&quot;&gt;&quot;wjohn1483@yahoo.com.tw&quot;&lt;/span&gt;
    git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.name &lt;span class=&quot;s2&quot;&gt;&quot;wjohn1483&quot;&lt;/span&gt;
    git remote add origin https://&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;GITHUB_TOKEN&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;@github.com/wjohn1483/wjohn1483.github.io.git
    git pull origin master
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

commit_website_files&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    git checkout master
    rsync &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--delete-after&lt;/span&gt; ../_site/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; ./
    git status
    git add &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
    git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Travis build: &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$TRAVIS_BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

upload_files&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    git push origin master
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;folder_to_push
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;folder_to_push

setup_git_folder
commit_website_files
upload_files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此就完成了線上編輯的所有步驟了，以後就能夠在GitHub網頁版上撰寫文章，commit完就直接部署到GitHub Page上。&lt;/p&gt;</content><author><name>Your Name</name></author><category term="Tool" /><summary type="html">這篇文章將會簡單介紹一下Jekyll，以及我如何使用Jekyll將網站建置在GitHub Page上的經歷。</summary></entry></feed>